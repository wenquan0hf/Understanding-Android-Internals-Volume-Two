<div> <h1><span>由于《深入理解Android 卷一》和《深入理解Android卷二》不再出版，而知识的传播不应该因为纸质媒介的问题而中断，所以我将在CSDN博客中全文转发这两本书的全部内容</span></h1> <h1>第4章  深入理解PackageManagerService</h1><h2>本章主要内容：</h2><p>详细分析PackageManagerService</p><h2>本章所涉及的源代码文件名及位置：</h2><p>·  SystemServer.java</p><p>frameworks/base/services/java/com/android/server/SystemServer.java</p><p>·   IPackageManager.aidl</p><p>frameworks/base/core/android/java/content/pm/IPackageManager.aidl</p><p>·  PackageManagerService.java</p><p>frameworks/base/services/java/com/android/server/pm/PackageManagerService.java</p><p>·  Settings.java</p><p>frameworks/base/services/java/com/android/server/pm/Settings.java</p><p>·  SystemUI的AndroidManifest.xml</p><p>frameworks/base/package/systemui/AndroidManifest.xml</p><p>·  PackageParser.java</p><p>frameworks/base/core/java/android/content/pm/PackageParser.java</p><p>·  commandline.c</p><p>system/core/adb/commandline.c</p><p>·  installd.c</p><p>frameworks/base/cmds/installd/installd.c</p><p>·  commands.c</p><p>frameworks/base/cmds/installd/commands.c</p><p>·  pm脚本文件</p><p>frameworks/base/cmds/pm/pm</p><p>·  Pm.java</p><p>frameworks/base/cmds/pm/src/com/android/commands/pm/Pm.java</p><p>·  DefaultContainerService.java</p><p>frameworks/base/packages/defaultcontainerservice/src/com/android/defaultcontainerservice/DefaultContainerService.java</p><p>·  UserManager.java</p><p>frameworks/base/services/java/com/android/server/pm/UserManager.java</p><p>·  UserInfo.java</p><p>frameworks/base/core/android/java/content/pm/UserInfo.java</p><h2>4.1  概述</h2><p>PackageManagerService是本书分析的第一个核心服务，也是Android系统中最常用的服务之一。它负责系统中Package的管理，应用程序的安装、卸载、信息查询等。图4-1展示了PackageManagerService及客户端的类家族。</p><p><img src="images/Center.jpg" alt="Center.jpg" /><br /></p><p>图4-1  PackageManagerService及客户端类家族</p><p>由图4-1可知：</p><p>·  IPackageManager接口类中定义了服务端和客户端通信的业务函数，还定义了内部类Stub，该类从Binder派生并实现了IPackageManager接口。</p><p>·  PackageManagerService继承自IPackageManager.Stub类，由于Stub类从Binder派生，因此PackageManagerService将作为服务端参与Binder通信。</p><p>·  Stub类中定义了一个内部类Proxy，该类有一个IBinder类型（实际类型为BinderProxy）的成员变量mRemote，根据第2章介绍的Binder系统的知识，mRemote用于和服务端PackageManagerService通信。</p><p>·  IPackageManager接口类中定义了许多业务函数，但是出于安全等方面的考虑，Android对外（即SDK）提供的只是一个子集，该子集被封装在抽象类PackageManager中。客户端一般通过Context的getPackageManager函数返回一个类型为PackageManager的对象，该对象的实际类型是PackageManager的子类ApplicationPackageManager。这种基于接口编程的方式，虽然极大降低了模块之间的耦合性，却给代码分析带来了不小的麻烦。</p><p>·  ApplicationPackageManager类继承自PackageManager类。它并没有直接参与Binder通信，而是通过mPM成员变量指向一个IPackageManager.Stub.Proxy类型的对象。</p><div><p><strong>提示</strong>读者在源码中可能找不到IPackageManager.java文件。该文件在编译过程中是经aidl工具处理IPackageManager.aidl后得到，最终的文件位置在Android源码/out/target</p><p>/common/obj/JAVA_LIBRARIES/framework_intermediates/src/core/java/android/content/pm/目录中。如果读者没有整体编译过源码，也可使用aidl工具单独处理IPackageManager.aidl。</p></div><p>aidl工具生成的结果文件有着相似的代码结构。读者不妨看看下面这个笔者通过编译生成的IPackageManager.java文件。注意，aidl工具生成的结果文件没有格式缩进，所以看起来惨不忍睹，读者可用Eclipse中的源文件格式化命令处理它。</p><p>[--&gt;IPackageManager.java]</p><div><p>public interface IPackageManager extendsandroid.os.IInterface {</p><p>     //定义内部类Stub，派生自Binder，实现IPackageManager接口</p><p>      publicstatic abstract class Stub extends android.os.Binder</p><p>                      implements  android.content.pm.IPackageManager {</p><p>            privatestatic final java.lang.String DESCRIPTOR =</p><p>                                   "android.content.pm.IPackageManager";</p><p>            publicStub() {</p><p>                 this.attachInterface(this,DESCRIPTOR);</p><p>             }</p><p>            ......</p><p>               //定义Stub的内部类Proxy，实现IPackageManager接口</p><p>            privatestatic class Proxy implements</p><p>                                   android.content.pm.IPackageManager{</p><p>                  //通过mRemote变量和服务端交互</p><p>                 private android.os.IBinder mRemote;</p><p>                         Proxy(android.os.IBinderremote) {</p><p>                         mRemote = remote;</p><p>                        }</p><p>                           ......</p><p>              }</p><p>          ......</p><p>}</p></div><p>接下来分析PackageManagerService，为书写方便起见，以后将其简称为PKMS。</p><h2>4.2  初识PackageManagerService</h2><p>PKMS作为系统的核心服务，由SystemServer创建，相关代码如下：</p><p>[--&gt;SystemServer.java]</p><div><p>......//ServerThread的run函数</p><p> /* </p><p> 4.0新增的一个功能，即设备加密（encrypting the device）,该功能由</p><p> 系统属性vold.decrypt指定。这部分功能比较复杂，本书暂不讨论。</p><p> 该功能对PKMS的影响就是通过onlyCore实现的，该变量用于判断是否只扫描系统库</p><p> （包括APK和Jar包）</p><p> */</p><p> StringcryptState = SystemProperties.get("vold.decrypt");</p><p> booleanonlyCore = false;</p><p> //ENCRYPTING_STATE的值为"trigger_restart_min_framework"</p><p> if(ENCRYPTING_STATE.equals(cryptState)) {</p><p>       ......</p><p>      onlyCore = true;</p><p> } else if(ENCRYPTED_STATE.equals(cryptState)) {</p><p>       ......//ENCRYPTED_STATE的值为"1"</p><p>     onlyCore = true;</p><p> }</p><p> //①调用PKMS的main函数，第二个参数用于判断是否为工厂测试，我们不讨论的这种情况，</p><p> //假定onlyCore的值为false</p><p> pm =PackageManagerService.main(context,</p><p>           factoryTest !=SystemServer.FACTORY_TEST_OFF,onlyCore);</p><p> booleanfirstBoot = false;</p><p> try {</p><p>         //判断本次是否为初次启动。当Zygote或SystemServer退出时，init会再次启动</p><p>        //它们，所以这里的FirstBoot是指开机后的第一次启动 </p><p>        firstBoot = pm.isFirstBoot();</p><p> } </p><p>......</p><p>  try {</p><p>        //②做dex优化。dex是Android上针对Java字节码的一种优化技术，可提高运行效率</p><p>       pm.performBootDexOpt();</p><p>  }</p><p> ......</p><p>  try {</p><p>        pm.systemReady();//③通知系统进入就绪状态</p><p> } </p><p>......</p><p>}//run函数结束</p></div><p>以上代码中共有4个关键调用，分别是：</p><p>·  PKMS的main函数。这个函数是PKMS的核心，稍后会重点分析它。</p><p>·  isFirstBoot、performBootDexOpt和systemReady。这3个函数比较简单。学完本章后，读者可完全自行分析它们，故这里不再赘述。</p><p>首先分析PKMS的main函数，它是核心函数，此处单独用一节进行分析。</p><h2>4.3  PKMS的main函数分析</h2><p>PKMS的main函数代码如下：</p><p>[--&gt;PackageManagerService.java]</p><div><p>public static final IPackageManager main(Contextcontext, boolean factoryTest,</p><p>           boolean onlyCore) {</p><p>        //调用PKMS的构造函数，factoryTest和onlyCore的值均为false</p><p>       PackageManagerService m = new PackageManagerService(context,</p><p>                                            factoryTest, onlyCore);</p><p>        //向ServiceManager注册PKMS</p><p>       ServiceManager.addService("package", m);</p><p>       return m;</p><p> }</p></div><p>main函数很简单，只有短短几行代码，执行时间却较长，主要原因是PKMS在其构造函数中做了很多“重体力活”，这也是Android启动速度慢的主要原因之一。在分析该函数前，先简单介绍一下PKMS构造函数的功能。</p><p>PKMS构造函数的主要功能是，扫描Android系统中几个目标文件夹中的APK，从而建立合适的数据结构以管理诸如Package信息、四大组件信息、权限信息等各种信息。抽象地看，PKMS像一个加工厂，它解析实际的物理文件（APK文件）以生成符合自己要求的产品。例如，PKMS将解析APK包中的AndroidManifest.xml，并根据其中声明的Activity标签来创建与此对应的对象并加以保管。</p><p>PKMS的工作流程相对简单，复杂的是其中用于保存各种信息的数据结构和它们之间的关系，以及影响最终结果的策略控制（例如前面代码中的onlyCore变量，用于判断是否只扫描系统目录）。曾经阅读过PKMS的读者可能会发现，代码中大量不同的数据结构以及它们之间的关系会令人大为头疼。所以，本章除了分析PKMS的工作流程外，也将关注重要的数据结构及它们的作用。</p><p>PKMS构造函数的工作流程大体可分三个阶段：</p><p>·  扫描目标文件夹之前的准备工作。</p><p>·  扫描目标文件夹。</p><p>·  扫描之后的工作。</p><p>该函数涉及到的知识点较多，代码段也较长，因此我们将通过分段讨论的方法，集中解决相关的重点问题。</p><h3>4.3.1  构造函数分析之前期准备工作</h3><p>下面开始分析构造函数第一阶段的工作，先看如下所示的代码。</p><p>[--&gt;PackageManagerService.java::构造函数]</p><div><p>public PackageManagerService(Context context,boolean factoryTest,</p><p>                                  booleanonlyCore) {</p><p>       ......</p><p>        if(mSdkVersion &lt;= 0) {</p><p>           /*</p><p>             mSdkVersion是PKMS的成员变量，定义的时候进行赋值，其值取自系统属性</p><p>             “ro.build.version.sdk”，即编译的SDK版本。如果没有定义，则APK</p><p>             就无法知道自己运行在Android哪个版本上</p><p>          */</p><p>           Slog.w(TAG, "**** ro.build.version.sdk not set!");//打印一句警告</p><p>        }</p><p>       mContext = context;</p><p>        mFactoryTest= factoryTest;//假定为false，即运行在非工厂模式下</p><p>       mOnlyCore = onlyCore;//假定为false，即运行在普通模式下</p><p>        //如果此系统是eng版，则扫描Package后，不对package做dex优化</p><p>       mNoDexOpt ="eng".equals(SystemProperties.get("ro.build.type"));</p><p>       //mMetrics用于存储与显示屏相关的一些属性，例如屏幕的宽/高尺寸，分辨率等信息</p><p>       mMetrics = new DisplayMetrics();</p><p>       //Settings是一个非常重要的类，该类用于存储系统运行过程中的一些设置，</p><p>        //下面进行详细分析        mSettings = new Settings();</p><p>       //①addSharedUserLPw是什么？马上来分析</p><p>       mSettings.addSharedUserLPw("android.uid.system",</p><p>               Process.SYSTEM_UID, ApplicationInfo.FLAG_SYSTEM);</p><p>       mSettings.addSharedUserLPw("android.uid.phone",</p><p>               MULTIPLE_APPLICATION_UIDS  //该变量的默认值是true</p><p>                        ? RADIO_UID :FIRST_APPLICATION_UID,</p><p>               ApplicationInfo.FLAG_SYSTEM);</p><p>       mSettings.addSharedUserLPw("android.uid.log",</p><p>               MULTIPLE_APPLICATION_UIDS</p><p>                        ? LOG_UID :FIRST_APPLICATION_UID,</p><p>               ApplicationInfo.FLAG_SYSTEM);</p><p>       mSettings.addSharedUserLPw("android.uid.nfc",</p><p>               MULTIPLE_APPLICATION_UIDS</p><p>                        ? NFC_UID :FIRST_APPLICATION_UID,</p><p>               ApplicationInfo.FLAG_SYSTEM);</p><p>       ......//第一段结束</p><p> </p></div><p>刚进入构造函数，就会遇到第一个较为复杂的数据结构Setting及它的addSharedUserLPw函数。Setting的作用是管理Android系统运行过程中的一些设置信息。到底是哪些信息呢？来看下面的分析。</p><h4>1.  初识Settings </h4><p>先分析addSharedUserLPw函数。此处截取该函数的调用代码，如下所示：</p><div><p>mSettings.addSharedUserLPw("android.uid.system",//字符串</p><p>              Process.SYSTEM_UID, //系统进程使用的用户id，值为1000 </p><p>              ApplicationInfo.FLAG_SYSTEM//标志系统Package</p><p>);</p></div><p>以此处的函数调用为例，我们为addSharedUserLPw传递了3个参数：</p><p>第一个是字符串“android.uid.system“；第二个是SYSTEM_UID，其值为1000；第三个是FLAG_SYSTEM标志，用于标识系统Package。</p><p>在进入对addSharedUserLPw函数的分析前，先介绍一下SYSTEM_UID 及相关知识。</p><h5>（1） Android系统中UID/GID介绍</h5><p>UID为用户ID的缩写，GID为用户组ID的缩写，这两个概念均与Linux系统中进程的权限管理有关。一般说来，每一个进程都会有一个对应的UID（即表示该进程属于哪个user，不同user有不同权限）。一个进程也可分属不同的用户组（每个用户组都有对应的权限）。</p><div><p><strong>提示</strong>Linux的UID/GID还可细分为几种类型，此处我们仅考虑普适意义的UID/GID。</p></div><p>如上所述，UID/GID和进程的权限有关。在Android平台中，系统定义的UID/GID在Process.java文件中，如下所示：</p><p>[--&gt;Process.java]</p><div><p>   //系统进程使用的UID/GID，值为1000</p><p>   publicstatic final int SYSTEM_UID = 1000;</p><p>   //Phone进程使用的UID/GID，值为1001</p><p>   publicstatic final int PHONE_UID = 1001;</p><p>   //shell进程使用的UID/GID，值为2000</p><p>   publicstatic final int SHELL_UID = 2000;</p><p>   //使用LOG的进程所在的组的UID/GID为1007</p><p>   publicstatic final int LOG_UID = 1007;</p><p>   //供WIF相关进程使用的UID/GID为1010</p><p>   publicstatic final int WIFI_UID = 1010;</p><p>  //mediaserver进程使用的UID/GID为1013</p><p>   publicstatic final int MEDIA_UID = 1013;</p><p>   //设置能读写SD卡的进程的GID为1015</p><p>   publicstatic final int SDCARD_RW_GID = 1015;</p><p>   //NFC相关的进程的UID/GID为1025</p><p>   publicstatic final int NFC_UID = 1025;</p><p>   //有权限读写内部存储的进程的GID为1023</p><p>   publicstatic final int MEDIA_RW_GID = 1023;</p><p>   //第一个应用Package的起始UID为10000</p><p>   publicstatic final int FIRST_APPLICATION_UID = 10000;</p><p>   //系统所支持的最大的应用Package的UID为99999</p><p>   publicstatic final int LAST_APPLICATION_UID = 99999;</p><p>   //和蓝牙相关的进程的GID为2000</p><p>   publicstatic final int BLUETOOTH_GID = 2000;</p></div><p>对不同的UID/GID授予不同的权限，接下来就介绍和权限设置相关的代码。</p><div><p><strong>提示</strong>读者可用adb shell（将什么？）登录到自己的手机，然后用busybox提供的ps命令查看进程的UID。</p></div><p>下面分析addSharedUserLPw函数，代码如下：</p><p>[--&gt;Settings.java]</p><div><p>SharedUserSetting addSharedUserLPw(String name,int uid, int pkgFlags) {</p><p>      /*</p><p>        注意这里的参数：name为字符串”android.uid.system”,uid为1000，pkgFlags为</p><p>        ApplicationInfo.FLAG_SYSETM(以后简写为FLAG_SYSTEM)</p><p>      */</p><p>       //mSharedUsers是一个HashMap，key为字符串，值为SharedUserSetting对象</p><p>       SharedUserSetting s = mSharedUsers.get(name);</p><p>        if(s != null) {</p><p>           if (s.userId == uid) {</p><p>               return s;</p><p>           }......</p><p>           return null;</p><p>        }</p><p>        //创建一个新的SharedUserSettings对象，并设置的userId为uid，</p><p>       //SharedUserSettings是什么？有什么作用？</p><p>        s =new SharedUserSetting(name, pkgFlags);</p><p>       s.userId = uid;</p><p>        if(addUserIdLPw(uid, s, name)) {</p><p>           mSharedUsers.put(name, s);//将name与s键值对添加到mSharedUsers中保存</p><p>           return s;</p><p>        }</p><p>       return null;</p><p>    }</p></div><p>从以上代码可知，Settings中有一个mSharedUsers成员，该成员存储的是字符串与SharedUserSetting键值对，也就是说以字符串为key得到对应的SharedUserSetting对象。</p><p>那么SharedUserSettings是什么？它的目的是什么？来看一个例子。</p><h5>（2） SharedUserSetting分析</h5><p>该例子来源于SystemUI的AndroidManifest.xml，如下所示：</p><p>[--&gt;SystemUI的AndroidManifest.xml]</p><div><p>&lt;manifestxmlns:android="http://schemas.android.com/apk/res/android"</p><p>       package="com.android.systemui"</p><p>       coreApp="true"</p><p>        android:sharedUserId="android.uid.system"</p><p>       android:process="system"&gt;</p><p> ......</p></div><p>在xml中，声明了一个名为android:sharedUserId的属性，其值为“android.uid.system”。sharedUserId看起来和UID有关，确实如此，它有两个作用：</p><p>·  两个或多个声明了同一种sharedUserIds的APK可共享彼此的数据，并且可运行在同一进程中。</p><p>·  更重要的是，通过声明特定的sharedUserId，该APK所在进程将被赋予指定的UID。例如，本例中的SystemUI声明了system的uid，运行SystemUI的进程就可享有system用户所对应的权限（实际上就是将该进程的uid设置为system的uid）了。</p><div><p><strong>提示</strong>除了在AndroidManifest.xml中声明sharedUserId外，APK在编译时还必须使用对应的证书进行签名。例如本例的SystemUI，在其Android.mk中需要额外声明LOCAL_CERTIFICATE := platform，如此，才可获得指定的UID。</p></div><p>通过以上介绍，读者能知道如何组织一种数据结构来包括上面的内容。此处有三个关键点需注意：</p><p>·  XML中sharedUserId属性指定了一个字符串，它是UID的字符串描述，故对应数据结构中也应该有这样一个字符串，这样就把代码和XML中的属性联系起来了。</p><p>·  在Linux系统中，真正的UID是一个整数，所以该数据结构中必然有一个整型变量。</p><p>·  多个Package可声明同一个sharedUserId，因此该数据结构必然会保存那些声明了相同sharedUserId的Package的某些信息。</p><p>了解了上面三个关键点，再来看Android是如何设计相应数据结构的，如图4-2所示。</p><p><img src="images/Center.jpg" alt="Center.jpg" /><br /></p><p>图4-2  SharedUserSetting类的关系图</p><p>由图4-2可知：</p><p>·  Settings类定义了一个mSharedUsers成员，它是一个HashMap，以字符串（如“android.uid.system”）为Key，对应的Value是一个SharedUserSettings对象。</p><p>·  SharedUserSetting派生自GrantedPermissions类，从GrantedPermissions类的命名可知，它和权限有关。SharedUserSetting定义了一个成员变量packages，类型为HashSet，用于保存声明了相同sharedUserId的Package的权限设置信息。</p><p>·  每个Package有自己的权限设置。权限的概念由PackageSetting类表达。该类继承自PackagesettingBase，而PackageSettingBase又继承自GrantedPermissions。</p><p>·  Settings中还有两个成员，一个是mUserIds，另一个是mOtherUserIds，这两位成员的类型分别是ArrayList和SparseArray。其目的是以UID为索引，得到对应的SharedUserSettings对象。在一般情况下，以索引获取数组元素的速度，比以key获取HashMap中元素的速度要快很多。</p><div><p><strong>提示</strong> 根据以上对mUserIds和mOtherUserIds的描述，可知这是典型的以空间换时间的做法。</p></div><p>下边来分析addUserIdLPw函数，它的功能就是将SharedUserSettings对象保存到对应的数组中，代码如下：</p><p>[--&gt;Settings.java]</p><div><p>private boolean addUserIdLPw(int uid, Object obj, Objectname) {</p><p>         //uid不能超出限制。Android对UID进行了分类，应用APK所在进程的UID从10000开始，</p><p>        //而系统APK所在进程小于10000</p><p>        if(uid &gt;= PackageManagerService.FIRST_APPLICATION_UID +</p><p>                            PackageManagerService.MAX_APPLICATION_UIDS){</p><p>           return false;</p><p>        }</p><p> </p><p>        if(uid &gt;= PackageManagerService.FIRST_APPLICATION_UID) {</p><p>           int N = mUserIds.size();</p><p>          //计算索引，其值是uid和FIRST_APPLICATION_UID的差</p><p>           final int index = uid - PackageManagerService.FIRST_APPLICATION_UID;</p><p>           while (index &gt;= N) {</p><p>               mUserIds.add(null); </p><p>               N++;</p><p>           }</p><p>            ......//判断该索引位置的内容是否为空，为空才保存</p><p>           mUserIds.set(index, obj);//mUserIds保存应用Package的UID</p><p>        }else {</p><p>           ......</p><p>            mOtherUserIds.put(uid, obj);//系统Package的UID由mOtherUserIds保存</p><p>        }</p><p>       return true;</p><p>}</p></div><p>至此，对Settings的分析就告一段落了。在这次“行程”中，我们重点分析了UID/GID以及SharedUserId方面的知识，并见识好几个重要的数据结构。希望读者通过SystemUI的实例能够理解这些数据结构存在的目的。</p><h4>2.  XML文件扫描</h4><p>下面继续分析PKMS的构造函数，代码如下：</p><p>[--&gt;PackageMangerService.java::构造函数]</p><div><p>       ......//接前一段</p><p>       String separateProcesses = //该值和调试有关。一般不设置该属性</p><p>                          SystemProperties.get("debug.separate_processes");</p><p>        if(separateProcesses != null &amp;&amp; separateProcesses.length() &gt; 0) {</p><p>          ......</p><p>        }else {</p><p>           mDefParseFlags = 0; </p><p>           mSeparateProcesses = null;</p><p>        }</p><p>        //创建一个Installer对象，该对象和Native进程installd交互，以后分析installd</p><p>        //时再来讨论它的作用</p><p>       mInstaller = new Installer();</p><p>       WindowManager wm =  //得到一个WindowManager对象</p><p>              (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);</p><p> </p><p>       Display d = wm.getDefaultDisplay();</p><p>       d.getMetrics(mMetrics); //获取当前设备的显示屏信息</p><p>       synchronized (mInstallLock) {</p><p>       synchronized (mPackages) {</p><p>           //创建一个ThreadHandler对象，实际就是创建一个带消息循环处理的线程，该线程</p><p>           //的工作是：程序的和卸载等。以后分析程序安装时会和它亲密接触</p><p>           mHandlerThread.start();</p><p>          //以ThreadHandler线程的消息循环(Looper对象)为参数创建一个PackageHandler，</p><p>           //可知该Handler的handleMessage函数将运行在此线程上</p><p>           mHandler = new PackageHandler(mHandlerThread.getLooper());</p><p>            File dataDir = Environment.getDataDirectory();</p><p>          // mAppDataDir指向/data/data目录</p><p>           mAppDataDir = new File(dataDir, "data");</p><p>           // mUserAppDataDir指向/data/user目录</p><p>           mUserAppDataDir = new File(dataDir, "user");</p><p>           // mDrmAppPrivateInstallDir指向/data/app-private目录</p><p>           mDrmAppPrivateInstallDir = new File(dataDir, "app-private");</p><p>           /*</p><p>            创建一个UserManager对象，目前没有什么作用，但其前途将不可限量。</p><p>             根据Google的设想，未来手机将支持多个User，每个User将安装自己的应用，</p><p>             该功能为Andorid智能手机推向企业用户打下坚实基础</p><p>            */</p><p>           mUserManager = new UserManager(mInstaller, mUserAppDataDir);</p><p>           //①从文件中读权限</p><p>           readPermissions();</p><p>           //②readLPw分析</p><p>           mRestoredSettings = mSettings.readLPw();</p><p>           long startTime = SystemClock.uptimeMillis();</p></div><p>以上代码中创建了几个对象，此处暂可不去理会它们。另外，以上代码中还调用了两个函数，分别是readPermission和Setttings的readLPw，它们有什么作用呢？下面就展开分析。</p><h5>（1） readPermissions函数分析</h5><p>先来分析readPermissions函数，从其函数名可猜测到它和权限有关，代码如下：</p><p>[--&gt;PackageManagerService.java]</p><div><p>void readPermissions() {</p><p>        // 指向/system/etc/permission目录，该目录中存储了和设备相关的一些权限信息</p><p>        FilelibraryDir = new File(Environment.getRootDirectory(),</p><p>                                        "etc/permissions");</p><p>        ......</p><p>        for(File f : libraryDir.listFiles()) {</p><p>           //先处理该目录下的非platform.xml文件</p><p>           if (f.getPath().endsWith("etc/permissions/platform.xml")) {</p><p>               continue;</p><p>           }</p><p>            ......//调用readPermissionFromXml解析此XML文件</p><p>           readPermissionsFromXml(f);</p><p>        }</p><p>       finalFile permFile = new File(Environment.getRootDirectory(),</p><p>               "etc/permissions/platform.xml");</p><p>        //解析platform.xml文件，看来该文件优先级最高</p><p>       readPermissionsFromXml(permFile);</p><p>}</p></div><p>悬着的心终于放了下来！readPermissions函数不就是调用readPermissionFromXml函数解析/system/etc/permissions目录下的文件吗？这些文件似乎都是XML文件。该目录下都有哪些XML文件呢？这些XML文件中有些什么内容呢？来看一个实际的例子，如图4-3所示。</p><p><img src="images/Center.jpg" alt="Center.jpg" /><br /></p><p>图4-3  /system/etc/permissions目录下的内容</p><p>图4-3中列出的是本人G7手机上/system/etc/permissions目录下的内容。在上面的代码中，虽然最后才解析platform.xml文件， 不过此处先分析此文件其内容如下所示：</p><p>[--&gt;platform.xml]</p><div><p>&lt;permissions&gt;</p><p>   &lt;!--建立权限名与gid的映射关系。如下面声明的BLUTOOTH_ADMIN权限，它对应的用户组是</p><p>    net_bt_admin。注意，该文件中的permission标签只对那些需要通过读写设备（蓝牙/camera）</p><p>     /创建socket等进程划分了gid。因为这些权限涉及和Linux内核交互，所以需要在底层</p><p>     权限（由不同的用户组界定）和Android层权限（由不同的字符串界定）之间建立映射关系</p><p>  --&gt;</p><p> &lt;permission name="android.permission.BLUETOOTH_ADMIN" &gt;</p><p>       &lt;group gid="net_bt_admin" /&gt;</p><p> &lt;/permission&gt;</p><p> &lt;permission name="android.permission.BLUETOOTH" &gt;</p><p>       &lt;group gid="net_bt" /&gt;</p><p>  &lt;/permission&gt;</p><p>  ......</p><p>   &lt;!--</p><p>     赋予对应uid相应的权限。如果下面一行表示uid为shell，那么就赋予</p><p>       它SEND_SMS的权限，其实就是把它加到对应的用户组中--&gt;</p><p>   &lt;assign-permission name="android.permission.SEND_SMS"uid="shell" /&gt;</p><p>   &lt;assign-permission name="android.permission.CALL_PHONE"uid="shell" /&gt;</p><p>   &lt;assign-permission name="android.permission.READ_CONTACTS"uid="shell" /&gt;</p><p>   &lt;assign-permission name="android.permission.WRITE_CONTACTS"uid="shell" /&gt;</p><p>    &lt;assign-permissionname="android.permission.READ_CALENDAR" uid="shell" /&gt;</p><p>......</p><p>    &lt;!-- 系统提供的Java库，应用程序运行时候必须要链接这些库，该工作由系统自动完成 --&gt;</p><p>    &lt;libraryname="android.test.runner"</p><p>           file="/system/frameworks/android.test.runner.jar" /&gt;</p><p>    &lt;library name="javax.obex"</p><p>           file="/system/frameworks/javax.obex.jar"/&gt;</p><p>&lt;/permissions&gt;</p></div><p>platform.xml文件中主要使用了如下4个标签：</p><p>·  permission和group用于建立Linux层gid和Android层pemission之间的映射关系。</p><p>·  assign-permission用于向指定的uid赋予相应的权限。这个权限由Android定义，用字符串表示。</p><p>·  library用于指定系统库。当应用程序运行时，系统会自动为这些进程加载这些库。</p><p>了解了platform.xml后，再看其他的XML文件，这里以handheld-core-hardware.xml为例进行介绍，其内容如下：</p><p>[--&gt;handheld-core-hardware.xml]</p><div><p>&lt;permissions&gt;</p><p>   &lt;feature name="android.hardware.camera" /&gt;</p><p>   &lt;feature name="android.hardware.location" /&gt;</p><p>   &lt;feature name="android.hardware.location.network" /&gt;</p><p>   &lt;feature name="android.hardware.sensor.compass" /&gt;</p><p>   &lt;feature name="android.hardware.sensor.accelerometer" /&gt;</p><p>   &lt;feature name="android.hardware.bluetooth" /&gt;</p><p>   &lt;feature name="android.hardware.touchscreen" /&gt;</p><p>   &lt;feature name="android.hardware.microphone" /&gt;</p><p>   &lt;feature name="android.hardware.screen.portrait" /&gt;</p><p>   &lt;feature name="android.hardware.screen.landscape" /&gt;</p><p>   &lt;/permissions&gt;</p></div><p>这个XML文件包含了许多feature标签。根据该文件中的注释，这些feature用来描述一个手持终端（包括手机、平板电脑等）应该支持的硬件特性，例如支持camera、支持蓝牙等。</p><div><p><strong>注意</strong>对于不同的硬件特性，还需要包含其他的xml文件。例如，要支持前置摄像头，还需要包含android.hardware.camera.front.xml文件。这些文件内容大体一样，都通过feature标签表明自己的硬件特性。相关说明可参考handheld-core-hardware.xml中的注释。</p></div><p>有读者可能会好奇，真实设备上/system/etc/permission目录中的文件是从哪里的呢？</p><p>答案是，在编译阶段由不同硬件平台根据自己的配置信息复制相关文件到目标目录中得来的。</p><p>这里给出一个例子，如图4-4所示。</p><p><img src="images/Center.jpg" alt="Center.jpg" /><br /></p><p>图4-4  /system/etc/permission目录中文件的来源</p><p>由图4-4可知，当编译的设备目标为htc-passion时，就会将Android源码目录/frameworks/base/data/etc/下某些和该目标设备硬件特性匹配的XML文件复制到最终输出目录/system/etc/permissions下。编译完成后，将生成system镜像。把该镜像文件烧到手机中，就成了目标设备使用的情况了。</p><div><p><strong>注意</strong>4.0源码中并没有htc相关的文件，这是笔者从2.3源码中移植过去的。读者可参考笔者一篇关于如何移植4.0到G7的博文，地址为<a>http://blog.csdn.net/innost/article/details/6977167</a>。</p></div><p>了解了与XML相关的知识后，再来分析readPermissionFromXml函数。相信聪明的读者已经知道它的作用了，就是将XML文件中的标签以及它们之间的关系转换成代码中的相应数据结构，代码如下：</p><p>[--&gt;PackageManagerService.java]</p><div><p>private void readPermissionsFromXml(File permFile){</p><p>       FileReader permReader = null;</p><p>        try{</p><p>           permReader = new FileReader(permFile);</p><p>        } ......</p><p>        try{</p><p>           XmlPullParser parser = Xml.newPullParser();</p><p>           parser.setInput(permReader);</p><p>           XmlUtils.beginDocument(parser, "permissions");</p><p>           while (true) {</p><p>               ......</p><p>               String name = parser.getName();</p><p>               //解析group标签，前面介绍的XML文件中没有单独使用该标签的地方</p><p>               if ("group".equals(name)) { </p><p>                   String gidStr = parser.getAttributeValue(null, "gid");</p><p>                   if (gidStr != null) {</p><p>                        int gid =Integer.parseInt(gidStr);</p><p>                        //转换XML中的gid字符串为整型，并保存到mGlobalGids中</p><p>                        mGlobalGids =appendInt(mGlobalGids, gid);</p><p>                   } ......</p><p>               } else if ("permission".equals(name)) {//解析permission标签</p><p>                   String perm = parser.getAttributeValue(null, "name");</p><p>                  ......</p><p>                   perm = perm.intern();</p><p>                     //调用readPermission处理</p><p>                   readPermission(parser, perm);</p><p>                 //下面解析的是assign-permission标签</p><p>                } else if("assign-permission".equals(name)) {</p><p>                   String perm = parser.getAttributeValue(null, "name");</p><p>                   ......</p><p>                   String uidStr = parser.getAttributeValue(null, "uid");</p><p>                   ......</p><p>                   //如果是assign-permission，则取出uid字符串，然后获得Linux平台上</p><p>                   //的整型uid值</p><p>                   int uid = Process.getUidForName(uidStr);</p><p>                  ......</p><p>                   perm = perm.intern();</p><p>                   //和assign相关的信息保存在mSystemPermissions中</p><p>                   HashSet&lt;String&gt; perms = mSystemPermissions.get(uid);</p><p>                   if (perms == null) {</p><p>                        perms = newHashSet&lt;String&gt;();</p><p>                       mSystemPermissions.put(uid, perms);</p><p>                   }</p><p>                   perms.add(perm);......</p><p>                  } else if ("library".equals(name)) {//解析library标签</p><p>                   String lname = parser.getAttributeValue(null, "name");</p><p>                   String lfile = parser.getAttributeValue(null, "file");</p><p>                   if (lname == null) {</p><p>                        ......</p><p>                   } else if (lfile == null) {</p><p>                        ......</p><p>                   } else {</p><p>                        //将XML中的name和library属性值存储到mSharedLibraries中</p><p>                       mSharedLibraries.put(lname,lfile);</p><p>                   } ......</p><p>               } else if ("feature".equals(name)) {//解析feature标签</p><p>                   String fname = parser.getAttributeValue(null, "name");</p><p>                    ......{</p><p>                        //在XML中定义的feature由FeatureInfo表达</p><p>                        FeatureInfo fi = newFeatureInfo();</p><p>                        fi.name = fname;</p><p>                        //存储feature名和对应的FeatureInfo到mAvailableFeatures中</p><p>                       mAvailableFeatures.put(fname, fi);</p><p>                   }......</p><p>                } ......</p><p>        } ......</p><p>    }</p></div><p>readPermissions函数果然将XML中的标签转换成对应的数据结构。总结相关的数据结构，如图4-4所示，此处借用了UML类图。在每个类图中，首行是数据结构名，第二行是数据结构的类型，第三行是注释。</p><p><img src="images/Center.jpg" alt="Center.jpg" /><br /></p><p>图4-4  通过readPermissions函数建立的数据结构及其关系</p><p>这里必须再次强调：图4-4中各种数据结构的目的是为了保存XML中各种标签及它们之间的关系。在分析过程中，最重要的是理解各种标签的作用，而不是它们所使用的数据结构。</p><h5>（2） readLPw的“佐料”</h5><p>readLPw函数的功能也是解析文件，不过这些文件的内容却是在PKMS正常启动后生成的。这里仅介绍作为readLPw“佐料”的文件的信息。文件的具体位置在Settings构造函数中指明，其代码如下：</p><p>[--&gt;Settings.java]</p><div><p>Settings() {</p><p>        FiledataDir = Environment.getDataDirectory();</p><p>        FilesystemDir = new File(dataDir, "system");//指向/data/system目录</p><p>       systemDir.mkdirs();//创建该目录</p><p>        ......</p><p>        /*</p><p>        一共有5个文件，packages.xml和packages-backup.xml为一组，用于描述系统中</p><p>        所安装的Package的信息，其中backup是临时文件。PKMS先把数据写到backup中，</p><p>        信息都写成功后再改名成非backup的文件。其目的是防止在写文件过程中出错，导致信息丢失。</p><p>         packages-stopped.xml和packages-stopped-backup.xml为一组，用于描述系统中</p><p>         强制停止运行的pakcage的信息，backup也是临时文件。如果此处存在该临时文件，表明</p><p>        此前系统因为某种原因中断了正常流程</p><p>        packages.list列出当前系统中应用级（即UID大于10000）Package的信息</p><p>        */</p><p>       mSettingsFilename = new File(systemDir, "packages.xml");</p><p>       mBackupSettingsFilename = new File(systemDir,"packages-backup.xml");</p><p>       mPackageListFilename = new File(systemDir, "packages.list");</p><p>       mStoppedPackagesFilename = new File(systemDir,"packages-stopped.xml");</p><p>       mBackupStoppedPackagesFilename = new File(systemDir,</p><p>                                            "packages-stopped-backup.xml");</p><p>}</p></div><p>上面5个文件共分为三组，这里简单介绍一下这些文件的来历（不考虑临时的backup文件）。</p><p>·  packages.xml： PKMS扫描完目标文件夹后会创建该文件。当系统进行程序安装、卸载和更新等操作时，均会更新该文件。该文件保存了系统中与package相关的一些信息。</p><p>·  packages.list：描述系统中存在的所有非系统自带的APK的信息。当这些程序有变动时，PKMS就会更新该文件。</p><p>·  packages-stopped.xml：从系统自带的设置程序中进入应用程序页面，然后在选择强制停止（ForceStop）某个应用时，系统会将该应用的相关信息记录到此文件中。也就是该文件保存系统中被用户强制停止的Package的信息。</p><p>readLPw的函数功能就是解析其中的XML文件的内容，然后建立并更新对应的数据结构，例如停止的package重启之后依然是stopped状态。</p><div><p><strong>提示</strong>读者看完本章后，可自行分析该函数。在此之前，建议读者不必关注该函数。</p></div><h4>3.  第一阶段工作总结</h4><p>在继续征程前，先总结一下PKMS构造函数在第一阶段的工作，千言万语汇成一句话：扫描并解析XML文件，将其中的信息保存到特定的数据结构中。</p><p>第一阶段扫描的XML文件与权限及上一次扫描得到的Package信息有关，它为PKMS下一阶段的工作提供了重要的参考信息。</p><h3>4.3.2  构造函数分析之扫描Package</h3><p>PKMS构造函数第二阶段的工作就是扫描系统中的APK了。由于需要逐个扫描文件，因此手机上装的程序越多，PKMS的工作量越大，系统启动速度也就越慢。</p><h4>1.  系统库的dex优化</h4><p>接着对PKMS构造函数进行分析，代码如下：</p><p>[--&gt;PackageManagerService.java]</p><div><p>......</p><p> mRestoredSettings= mSettings.readLPw();//接第一段的结尾</p><p> longstartTime = SystemClock.uptimeMillis();//记录扫描开始的时间</p><p>//定义扫描参数</p><p> intscanMode = SCAN_MONITOR | SCAN_NO_PATHS | SCAN_DEFER_DEX;</p><p> if(mNoDexOpt) {</p><p>    scanMode|= SCAN_NO_DEX; //在控制扫描过程中是否对APK文件进行dex优化 </p><p>  }</p><p> finalHashSet&lt;String&gt; libFiles = new HashSet&lt;String&gt;();</p><p> // mFrameworkDir指向/system/frameworks目录</p><p> mFrameworkDir = newFile(Environment.getRootDirectory(),"framework");</p><p> // mDalvikCacheDir指向/data/dalvik-cache目录</p><p> mDalvikCacheDir= new File(dataDir, "dalvik-cache");</p><p> booleandidDexOpt = false;</p><p> /*</p><p>  获取Java启动类库的路径，在init.rc文件中通过BOOTCLASSPATH环境变量输出，该值如下</p><p>  /system/framework/core.jar:/system/frameworks/core-junit.jar:</p><p>  /system/frameworks/bouncycastle.jar:/system/frameworks/ext.jar:</p><p>  /system/frameworks/framework.jar:/system/frameworks/android.policy.jar:</p><p>  /system/frameworks/services.jar:/system/frameworks/apache-xml.jar:</p><p>  /system/frameworks/filterfw.jar</p><p>  该变量指明了framework所有核心库及文件位置</p><p> */</p><p> StringbootClassPath = System.getProperty("java.boot.class.path");</p><p> if(bootClassPath != null) {</p><p>     String[] paths = splitString(bootClassPath, ':');</p><p>      for(int i=0; i&lt;paths.length; i++) {</p><p>        try{  //判断该jar包是否需要重新做dex优化</p><p>             if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {</p><p>                  /*</p><p>                   将该jar包文件路径保存到libFiles中，然后通过mInstall对象发送</p><p>                   命令给installd，让其对该jar包进行dex优化</p><p>                  */</p><p>                  libFiles.add(paths[i]); </p><p>                  mInstaller.dexopt(paths[i], Process.SYSTEM_UID, true);</p><p>                  didDexOpt = true;</p><p>                }</p><p>              } ......</p><p>           }</p><p>      } ......</p><p>   /*</p><p>    读者还记得mSharedLibrarires的作用吗？它保存的是platform.xml中声明的系统库的信息。</p><p>    这里也要判断系统库是否需要做dex优化。处理方式同上</p><p>   */</p><p>if (mSharedLibraries.size() &gt; 0) {</p><p>     ......</p><p> }</p><p>     //将framework-res.apk添加到libFiles中。framework-res.apk定义了系统常用的</p><p>    //资源，还有几个重要的Activity，如长按Power键后弹出的选择框</p><p>    libFiles.add(mFrameworkDir.getPath() + "/framework-res.apk");</p><p>     //列举/system/frameworks目录中的文件</p><p>    String[] frameworkFiles = mFrameworkDir.list();</p><p>     if(frameworkFiles != null) {</p><p>         ......//判断该目录下的apk或jar文件是否需要做dex优化。处理方式同上</p><p> }</p><p>   /*</p><p>   上面代码对系统库（BOOTCLASSPATH指定，或 platform.xml定义，或</p><p>  /system/frameworks目录下的jar包与apk文件）进行一次仔细检查，该优化的一定要优化。</p><p>  如果发现期间对任何一个文件进行了优化，则设置didDexOpt为true</p><p>  */</p><p>     if (didDexOpt) {</p><p>      String[] files = mDalvikCacheDir.list();</p><p>        if (files != null) {</p><p>          /*</p><p>         如果前面对任意一个系统库重新做过dex优化，就需要删除cache文件。原因和</p><p>         dalvik虚拟机的运行机制有关。本书暂不探讨dex及cache文件的作用。</p><p>         从删除cache文件这个操作来看，这些cache文件应该使用了dex优化后的系统库</p><p>         所以当系统库重新做dex优化后，就需要删除旧的cache文件。可简单理解为缓存失效</p><p>        */</p><p>             for (int i=0; i&lt;files.length; i++) {</p><p>                   String fn = files[i];</p><p>                     if(fn.startsWith("data@app@")</p><p>                          ||fn.startsWith("data@app-private@")) {</p><p>                          (newFile(mDalvikCacheDir, fn)).delete();</p><p>        ......</p><p> }</p></div><h4>2.  扫描系统Package</h4><p>清空cache文件后，PKMS终于进入重点段了。接下来看PKMS第二阶段工作的核心内容，即扫描Package，相关代码如下：</p><p>[--&gt;PackageManagerService.java]</p><div><p>   //创建文件夹监控对象，监视/system/frameworks目录。利用了Linux平台的inotify机制</p><p>  mFrameworkInstallObserver = new AppDirObserver(</p><p>                      mFrameworkDir.getPath(),OBSERVER_EVENTS, true);</p><p>   mFrameworkInstallObserver.startWatching();</p><p> /*</p><p>  调用scanDirLI函数扫描/system/frameworks目录，这个函数很重要，稍后会再分析。</p><p>  注意，在第三个参数中设置了SCAN_NO_DEX标志，因为该目录下的package在前面的流程</p><p>  中已经过判断并根据需要做过dex优化了</p><p> */</p><p>   scanDirLI(mFrameworkDir, PackageParser.PARSE_IS_SYSTEM</p><p>            | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX, 0);</p><p>     //创建文件夹监控对象，监视/system/app目录 </p><p>   mSystemAppDir = new File(Environment.getRootDirectory(),"app");</p><p>   mSystemInstallObserver = new AppDirObserver(</p><p>               mSystemAppDir.getPath(), OBSERVER_EVENTS, true);</p><p>    mSystemInstallObserver.startWatching();</p><p> //扫描/system/app下的package</p><p>   scanDirLI(mSystemAppDir, PackageParser.PARSE_IS_SYSTEM</p><p>                   | PackageParser.PARSE_IS_SYSTEM_DIR, scanMode, 0);</p><p>     //监视并扫描/vendor/app目录</p><p>   mVendorAppDir = new File("/vendor/app");</p><p>   mVendorInstallObserver = new AppDirObserver(</p><p>               mVendorAppDir.getPath(), OBSERVER_EVENTS, true);</p><p>    mVendorInstallObserver.startWatching();</p><p>    //扫描/vendor/app下的package</p><p>   scanDirLI(mVendorAppDir, PackageParser.PARSE_IS_SYSTEM</p><p>                   | PackageParser.PARSE_IS_SYSTEM_DIR, scanMode, 0);</p><p>    //和installd交互。以后单独分析installd</p><p>   mInstaller.moveFiles();</p></div><p>由以上代码可知，PKMS将扫描以下几个目录。</p><p>·  /system/frameworks：该目录中的文件都是系统库，例如framework.jar、services.jar、framework-res.apk。不过scanDirLI只扫描APK文件，所以framework-res.apk是该目录中唯一“受宠”的文件。</p><p>·  /system/app：该目录下全是默认的系统应用，例如Browser.apk、SettingsProvider.apk等。</p><p>·  /vendor/app：该目录中的文件由厂商提供，即厂商特定的APK文件，不过目前市面上的厂商都把自己的应用放在/system/app目录下。</p><div><p><strong>注意</strong>本书把这三个目录称为系统Package目录，以区分后面的非系统Package目录。</p></div><p>PKMS调用scanDirLI函数进行扫描，下面来分析此函数。 </p><h5>（1） scanDirLI函数分析</h5><p>scanDirLI函数的代码如下：</p><p>[--&gt;PackageManagerService.java]</p><div><p>private void scanDirLI(File dir, int flags, intscanMode, long currentTime) {</p><p>       String[] files = dir.list();//列举该目录下的文件</p><p>       ......</p><p>        inti;</p><p>        for(i=0; i&lt;files.length; i++) {</p><p>           File file = new File(dir, files[i]);</p><p>           if (!isPackageFilename(files[i])) {</p><p>                continue; //根据文件名后缀，判断是否为APK 文件。这里只扫描APK 文件</p><p>           }</p><p>           /*</p><p>            调用scanPackageLI函数扫描一个特定的文件，返回值是PackageParser的内部类</p><p>            Package，该类的实例代表一个APK文件，所以它就是和APK文件对应的数据结构</p><p>          */</p><p>           PackageParser.Package pkg = scanPackageLI(file,</p><p>                flags|PackageParser.PARSE_MUST_BE_APK, scanMode, currentTime);</p><p>             if (pkg == null &amp;&amp; (flags &amp;PackageParser.PARSE_IS_SYSTEM) == 0 &amp;&amp;</p><p>               mLastScanError ==PackageManager.INSTALL_FAILED_INVALID_APK) {</p><p>               //注意此处flags的作用，只有非系统Package扫描失败，才会删除该文件 </p><p>               file.delete();</p><p>           }</p><p>   }</p><p>}</p></div><p>接着来分析scanPackageLI函数。PKMS中有两个同名的scanPackageLI函数，后面会一一见到。先来看第一个也是最先碰到的scanPackageLI函数。</p><h5>（2） 初会scanPackageLI函数</h5><p>首次相遇的scanPackageLI函数的代码如下：</p><p>[--&gt;PackageManagerService.java]</p><div><p>private PackageParser.Package scanPackageLI(FilescanFile, int parseFlags,</p><p>                                       int scanMode, long currentTime)</p><p>{</p><p>     mLastScanError = PackageManager.INSTALL_SUCCEEDED;</p><p>      StringscanPath = scanFile.getPath();</p><p>     parseFlags |= mDefParseFlags;//默认的扫描标志，正常情况下为0</p><p>      //创建一个PackageParser对象</p><p>     PackageParser pp = new PackageParser(scanPath);</p><p>     pp.setSeparateProcesses(mSeparateProcesses);// mSeparateProcesses为空</p><p>     pp.setOnlyCoreApps(mOnlyCore);// mOnlyCore为false</p><p>      /*</p><p>       调用PackageParser的parsePackage函数解析APK文件。注意，这里把代表屏幕</p><p>       信息的mMetrics对象也传了进去</p><p>       */</p><p>      finalPackageParser.Package pkg = pp.parsePackage(scanFile,</p><p>               scanPath, mMetrics, parseFlags);</p><p>        ......</p><p>     PackageSetting ps = null;</p><p>     PackageSetting updatedPkg;</p><p>        ......</p><p>      /*</p><p>        这里略去一大段代码，主要是关于Package升级方面的工作。读者可能会比较好奇：既然是</p><p>        升级，一定有新旧之分，如果这里刚解析后得到的Package信息是新，那么旧Package</p><p>        的信息从何得来？还记得”readLPw的‘佐料’”这一小节提到的package.xml文件吗？此</p><p>        文件中存储的就是上一次扫描得到的Package信息。对比这两次的信息就知道是否需要做</p><p>        升级了。这部分代码比较繁琐，但不影响我们正常分析。感兴趣的读者可自行研究</p><p>      */</p><p>      //收集签名信息，这部分内容涉及signature，本书暂不拟讨论<a><span>[</span><span>①</span><span>]</span></a>。</p><p>      if (!collectCertificatesLI(pp, ps, pkg,scanFile, parseFlags)) </p><p>           returnnull;</p><p>     //判断是否需要设置PARSE_FORWARD_LOCK标志，这个标志针对资源文件和Class文件</p><p>     //不在同一个目录的情况。目前只有/vendor/app目录下的扫描会使用该标志。这里不讨论</p><p>     //这种情况。</p><p>      if (ps != null &amp;&amp;!ps.codePath.equals(ps.resourcePath))</p><p>           parseFlags|= PackageParser.PARSE_FORWARD_LOCK;</p><p>        String codePath = null;</p><p>       String resPath = null;</p><p>        if((parseFlags &amp; PackageParser.PARSE_FORWARD_LOCK) != 0) {</p><p>            ......//这里不考虑PARSE_FORWARD_LOCK的情况。</p><p>        }else {</p><p>           resPath = pkg.mScanPath;</p><p>        }</p><p>       codePath = pkg.mScanPath;//mScanPath指向该APK文件所在位置</p><p>        //设置文件路径信息，codePath和resPath都指向APK文件所在位置</p><p>       setApplicationInfoPaths(pkg, codePath, resPath);</p><p>        //调用第二个scanPackageLI函数</p><p>       return scanPackageLI(pkg, parseFlags, scanMode | SCAN_UPDATE_SIGNATURE,</p><p>                                 currentTime);</p><p>}</p></div><p>scanPackageLI函数首先调用PackageParser对APK文件进行解析。根据前面的介绍可知，PackageParser完成了从物理文件到对应数据结构的转换。下面来分析这个PackageParser。</p><h5>（3） PackageParser分析</h5><p>PackageParser主要负责APK文件的解析，即解析APK文件中的AndroidManifest.xml代码如下：</p><p>[--&gt;PackageParser.java]</p><div><p> publicPackage parsePackage(File sourceFile, String destCodePath,</p><p>           DisplayMetrics metrics, int flags) {</p><p>       mParseError = PackageManager.INSTALL_SUCCEEDED;</p><p> </p><p>       mArchiveSourcePath = sourceFile.getPath();</p><p>        ......//检查是否为APK文件</p><p>      XmlResourceParser parser = null;</p><p>       AssetManager assmgr = null;</p><p>       Resources res = null;</p><p>       boolean assetError = true;</p><p>        try{</p><p>           assmgr = new AssetManager();</p><p>           int cookie = assmgr.addAssetPath(mArchiveSourcePath);</p><p>           if (cookie != 0) {</p><p>               res = new Resources(assmgr, metrics, null);</p><p>               assmgr.setConfiguration(0, 0, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, </p><p>                              0, 0, 0, 0,Build.VERSION.RESOURCES_SDK_INT);</p><p>          /*</p><p>           获得一个XML资源解析对象，该对象解析的是APK中的AndroidManifest.xml文件。</p><p>           以后再讨论AssetManager、Resource及相关的知识</p><p>         */</p><p>            parser = assmgr.openXmlResourceParser(cookie, </p><p>                                                  ANDROID_MANIFEST_FILENAME);</p><p>               assetError = false;</p><p>           } ......//出错处理</p><p>       String[] errorText = new String[1];</p><p>       Package pkg = null;</p><p>       Exception errorException = null;</p><p>        try {</p><p>           //调用另外一个parsePackage函数</p><p>           pkg = parsePackage(res, parser, flags, errorText);</p><p>        } ......</p><p>        ......//错误处理</p><p>       parser.close();</p><p>       assmgr.close();</p><p>       //保存文件路径，都指向APK文件所在的路径</p><p>       pkg.mPath = destCodePath;</p><p>       pkg.mScanPath = mArchiveSourcePath;</p><p>       pkg.mSignatures = null;</p><p>       return pkg;</p><p>}</p></div><p>以上代码中调用了另一个同名的PackageParser函数，此函数内容较长，但功能单一，就是解析AndroidManifest.xml中的各种标签，这里只提取其中相关的代码：</p><p>[--&gt;PackageParser.java]</p><div><p>private Package parsePackage(</p><p>       Resources res, XmlResourceParser parser, int flags, String[] outError)</p><p>       throws XmlPullParserException, IOException {</p><p>       AttributeSet attrs = parser;</p><p> </p><p>       mParseInstrumentationArgs = null;</p><p>       mParseActivityArgs = null;</p><p>        mParseServiceArgs= null;</p><p>       mParseProviderArgs = null;</p><p>       //得到Package的名字，其实就是得到AndroidManifest.xml中package属性的值，</p><p>       //每个APK都必须定义该属性</p><p>       String pkgName = parsePackageName(parser, attrs, flags, outError);</p><p>        ......</p><p>        inttype;</p><p>       ......</p><p>        //以pkgName名字为参数，创建一个Package对象。后面的工作就是解析XML并填充</p><p>       //该Package信息</p><p>       finalPackage pkg = new Package(pkgName);</p><p>       boolean foundApp = false;</p><p>       ......//下面开始解析该文件中的标签，由于这段代码功能简单，所以这里仅列举相关函数</p><p>      while(如果解析未完成){</p><p>      ......</p><p>       StringtagName = parser.getName(); //得到标签名</p><p>       if(tagName.equals("application")){</p><p>          ......//解析application标签</p><p>           parseApplication(pkg,res, parser, attrs, flags, outError);</p><p>       } elseif (tagName.equals("permission-group")) {</p><p>        ......//解析permission-group标签</p><p>        parsePermissionGroup(pkg, res, parser, attrs, outError);</p><p>       } elseif (tagName.equals("permission")) {</p><p>        ......//解析permission标签</p><p>        parsePermission(pkg, res, parser, attrs, outError);</p><p>       } else if(tagName.equals("uses-permission")){</p><p>          //从XML文件中获取uses-permission标签的属性</p><p>          sa= res.obtainAttributes(attrs,</p><p>            com.android.internal.R.styleable.AndroidManifestUsesPermission);</p><p>          //取出属性值，也就是对应的权限使用声明</p><p>         String name = sa.getNonResourceString(com.android.internal.</p><p>                               R.styleable.AndroidManifestUsesPermission_name);</p><p>          //添加到Package的requestedPermissions数组</p><p>          if(name != null &amp;&amp; !pkg.requestedPermissions.contains(name)) {</p><p>               pkg.requestedPermissions.add(name.intern());</p><p>          }</p><p>       }elseif (tagName.equals("uses-configuration")){</p><p>        /*</p><p>           该标签用于指明本package对硬件的一些设置参数，目前主要针对输入设备（触摸屏、键盘</p><p>           等）。游戏类的应用可能对此有特殊要求。</p><p>       */</p><p>         ConfigurationInfocPref = new ConfigurationInfo();</p><p>        ......//解析该标签所支持的各种属性</p><p>        pkg.configPreferences.add(cPref);//保存到Package的configPreferences数组</p><p>       }</p><p>      ......//对其他标签解析和处理</p><p>}</p></div><p>上面代码展示了AndroidManifest.xml解析的流程，其中比较重要的函数是parserApplication，它用于解析application标签及其子标签（Android的四大组件在application标签中已声明）。</p><p>图4-5表示了PackageParser及其内部重要成员的信息。</p><p><img src="images/Center.jpg" alt="Center.jpg" /><br /></p><p>图4-5  PackageParser大家族</p><p>由图4-5可知：</p><p>·  PackageParser定了相当多的内部类，这些内部类的作用就是保存对应的信息。解析AndroidManifest.xml文件得到的信息由Package保存。从该类的成员变量可看出，和Android四大组件相关的信息分别由activites、receivers、providers、services保存。由于一个APK可声明多个组件，因此activites和receivers等均声明为ArrayList。</p><p>·  以<a>PackageParser.</a>Activity为例，它从Component&lt;ActivityIntentInfo&gt;派生。Component是一个模板类，元素类型是ActivityIntentInfo，此类的顶层基类是IntentFilter。PackageParser.Activity内部有一个ActivityInfo类型的成员变量，该变量保存的就是四大组件中Activity的信息。细心的读者可能会有疑问，为什么不直接使用ActivityInfo，而是通过IntentFilter构造出一个使用模板的复杂类型PackageParser.Activity呢？原来，Package除了保存信息外，还需要支持Intent匹配查询。例如，设置Intent的Action为某个特定值，然后查找匹配该Intent的Activity。由于ActivityIntentInfo是从IntentFilter派生的，因此它它能判断自己是否满足该Intent的要求，如果满足，则返回对应的ActivityInfo。在后续章节会详细讨论根据Intent查询特定Activity的工作流程。 </p><p>·  PackageParser定了一个轻量级的数据结构PackageLite，该类仅存储Package的一些简单信息。我们在介绍Package安装的时候，会遇到PackageLite。</p><div><p><strong>注意</strong>读者需要了解Java泛型类的相关知识。 </p></div><h5>（4） 与scanPackageLI再相遇</h5><p>在PackageParser扫描完一个APK后，此时系统已经根据该APK中AndroidManifest.xm，创建了一个完整的Package对象，下一步就是将该Package加入到系统中。此时调用的函数就是另外一个scanPackageLI，其代码如下：</p><p>[--&gt;PackageManagerService.java::scanPackageLI函数]</p><div><p>private PackageParser.PackagescanPackageLI(PackageParser.Package pkg,</p><p>           int parseFlags, int scanMode, long currentTime) {</p><p>        FilescanFile = new File(pkg.mScanPath);</p><p>        ......</p><p>       mScanningPath = scanFile;</p><p>        //设置package对象中applicationInfo的flags标签，用于标示该Package为系统</p><p>       //Package</p><p>        if((parseFlags&amp;PackageParser.PARSE_IS_SYSTEM) != 0) {</p><p>           pkg.applicationInfo.flags |= ApplicationInfo.FLAG_SYSTEM;</p><p>        }</p><p>        //①下面这句if判断极为重要，见下面的解释</p><p>        if(pkg.packageName.equals("android")) {</p><p>           synchronized (mPackages) {</p><p>               if (mAndroidApplication != null) {</p><p>                  ......</p><p>               mPlatformPackage = pkg;</p><p>               pkg.mVersionCode = mSdkVersion;</p><p>               mAndroidApplication = pkg.applicationInfo;</p><p>               mResolveActivity.applicationInfo = mAndroidApplication;</p><p>               mResolveActivity.name = ResolverActivity.class.getName();</p><p>               mResolveActivity.packageName = mAndroidApplication.packageName;</p><p>               mResolveActivity.processName = mAndroidApplication.processName;</p><p>               mResolveActivity.launchMode = ActivityInfo.LAUNCH_MULTIPLE;</p><p>               mResolveActivity.flags = ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;</p><p>               mResolveActivity.theme =</p><p>                          com.android.internal.R.style.Theme_Holo_Dialog_Alert;</p><p>               mResolveActivity.exported = true;</p><p>               mResolveActivity.enabled = true;</p><p>               //mResoveInfo的activityInfo成员指向mResolveActivity</p><p>               mResolveInfo.activityInfo = mResolveActivity;</p><p>               mResolveInfo.priority = 0;</p><p>               mResolveInfo.preferredOrder = 0;</p><p>               mResolveInfo.match = 0;</p><p>               mResolveComponentName = new ComponentName(</p><p>                       mAndroidApplication.packageName, mResolveActivity.name);</p><p>           }</p><p>        }</p></div><p>刚进入scanPackageLI函数，我们就发现了一个极为重要的内容，即单独判断并处理packageName为“android”的Package。和该Package对应的APK是framework-res.apk，有图为证，如图4-6所示为该APK的AndroidManifest.xml中的相关内容。</p><p><img src="images/Center.jpg" alt="Center.jpg" /><br /></p><p>图4-6  framework-res.apk的AndroidManifest.xml</p><p>实际上，framework-res.apk还包含了以下几个常用的Activity。</p><p>·  ChooserActivity：当多个Activity符合某个Intent的时候，系统会弹出此Activity，由用户选择合适的应用来处理。</p><p>·  RingtonePickerActivity：铃声选择Activity。</p><p>·  ShutdownActivity：关机前弹出的选择对话框。</p><p>由前述知识可知，该Package和系统息息相关，因此它得到了PKMS的特别青睐，主要体现在以下几点。</p><p>·  mPlatformPackage成员用于保存该Package信息。</p><p>·  mAndroidApplication用于保存此Package中的ApplicationInfo。</p><p>·  mResolveActivity指向用于表示ChooserActivity信息的ActivityInfo。</p><p>·  mResolveInfo为ResolveInfo类型，它用于存储系统解析Intent（经IntentFilter的过滤）后得到的结果信息，例如满足某个Intent的Activity的信息。由前面的代码可知，mResolveInfo的activityInfo其实指向的就是mResolveActivity。</p><div><p><strong>注意</strong>在从PKMS中查询满足某个Intent的Activity时，返回的就是ResolveInfo，再根据ResolveInfo的信息得到具体的Activity。</p></div><p>此处保存这些信息，主要是为了提高运行过程中的效率。Goolge工程师可能觉得ChooserActivity使用的地方比较多，所以这里单独保存了此Activity的信息。</p><p>好，继续对scanPackageLI函数的分析。</p><p>[--&gt;PackageManagerService::scanPackageLI函数]</p><div><p>......//mPackages用于保存系统内的所有Package，以packageName为key</p><p>   if(mPackages.containsKey(pkg.packageName)</p><p>               || mSharedLibraries.containsKey(pkg.packageName)) {</p><p>       return null;</p><p>   }</p><p>      File destCodeFile = newFile(pkg.applicationInfo.sourceDir);</p><p>      FiledestResourceFile = new File(pkg.applicationInfo.publicSourceDir);</p><p>      SharedUserSettingsuid = null;//代表该Package的SharedUserSetting对象</p><p>     PackageSetting pkgSetting = null;//代表该Package的PackageSetting对象</p><p>      synchronized(mPackages) {</p><p>         ......//此段代码大约有300行左右，主要做了以下几方面工作</p><p>         /*</p><p>          ①如果该Packge声明了” uses-librarie”话，那么系统要判断该library是否</p><p>            在mSharedLibraries中</p><p>          ②如果package声明了SharedUser，则需要处理SharedUserSettings相关内容，</p><p>            由Settings的getSharedUserLPw函数处理</p><p>           ③处理pkgSetting，通过调用Settings的getPackageLPw函数完成</p><p>           ④调用verifySignaturesLP函数，检查该Package的signature</p><p>          */</p><p>       }</p><p>      finallong scanFileTime = scanFile.lastModified();</p><p>      finalboolean forceDex = (scanMode&amp;SCAN_FORCE_DEX) != 0;</p><p>      //确定运行该package的进程的进程名，一般用packageName作为进程名</p><p>     pkg.applicationInfo.processName = fixProcessName(</p><p>                         pkg.applicationInfo.packageName,</p><p>                         pkg.applicationInfo.processName,</p><p>                         pkg.applicationInfo.uid);</p><p>      if(mPlatformPackage == pkg) {</p><p>           dataPath = new File (Environment.getDataDirectory(),"system");</p><p>           pkg.applicationInfo.dataDir = dataPath.getPath();</p><p>        }else {</p><p>            /*</p><p>             getDataPathForPackage函数返回该package的目录 </p><p>            一般是/data/data/packageName/</p><p>           */</p><p>           dataPath = getDataPathForPackage(pkg.packageName, 0);</p><p>            if(dataPath.exists()){</p><p>             ......//如果该目录已经存在，则要处理uid的问题</p><p>           } else {</p><p>             ......//向installd发送install命令，实际上就是在/data/data下</p><p>                   //建立packageName目录。后续将分析installd相关知识</p><p>               int ret = mInstaller.install(pkgName, pkg.applicationInfo.uid,</p><p>                       pkg.applicationInfo.uid);</p><p>              //为系统所有user安装此程序</p><p>               mUserManager.installPackageForAllUsers(pkgName,</p><p>                                pkg.applicationInfo.uid);</p><p> </p><p>               if (dataPath.exists()) {</p><p>                   pkg.applicationInfo.dataDir = dataPath.getPath();</p><p>               } ......</p><p>               </p><p>               if (pkg.applicationInfo.nativeLibraryDir == null &amp;&amp;</p><p>                      pkg.applicationInfo.dataDir!= null) {</p><p>               ......//为该Package确定native library所在目录</p><p>              //一般是/data/data/packagename/lib</p><p>           }</p><p>}</p><p>    //如果该APK包含了native动态库，则需要将它们从APK文件中解压并复制到对应目录中</p><p>    if(pkg.applicationInfo.nativeLibraryDir != null) {</p><p>           try {</p><p>               final File nativeLibraryDir = new</p><p>                            File(pkg.applicationInfo.nativeLibraryDir);</p><p>               final String dataPathString = dataPath.getCanonicalPath();</p><p>               //从2.3开始，系统package的native库统一放在/system/lib下。所以</p><p>               //系统不会提取系统Package目录下APK包中的native库</p><p>               if (isSystemApp(pkg) &amp;&amp; !isUpdatedSystemApp(pkg)) {</p><p>                   NativeLibraryHelper.removeNativeBinariesFromDirLI(</p><p>                                            nativeLibraryDir)){</p><p>           } else if (nativeLibraryDir.getParentFile().getCanonicalPath()</p><p>                       .equals(dataPathString)) {</p><p>                   boolean isSymLink;</p><p>                   try {</p><p>                        isSymLink = S_ISLNK(Libcore.os.lstat(</p><p>                                        nativeLibraryDir.getPath()).st_mode);</p><p>                   } ......//判断是否为链接，如果是，需要删除该链接</p><p>                   if (isSymLink) {</p><p>                       mInstaller.unlinkNativeLibraryDirectory(dataPathString);</p><p>                   }</p><p>             //在lib下建立和CPU类型对应的目录，例如ARM平台的是arm/，MIPS平台的是mips/</p><p>               NativeLibraryHelper.copyNativeBinariesIfNeededLI(scanFile,</p><p>                                   nativeLibraryDir);</p><p>               } else {</p><p>                   mInstaller.linkNativeLibraryDirectory(dataPathString,</p><p>                                       pkg.applicationInfo.nativeLibraryDir);</p><p>               }</p><p>           } ......</p><p>        }</p><p>     pkg.mScanPath= path;</p><p>     if((scanMode&amp;SCAN_NO_DEX) == 0) {</p><p>            ......//对该APK做dex优化</p><p>        performDexOptLI(pkg,forceDex, (scanMode&amp;SCAN_DEFER_DEX);</p><p>      }</p><p>     //如果该APK已经存在，要先杀掉运行该APK的进程</p><p>     if((parseFlags &amp; PackageManager.INSTALL_REPLACE_EXISTING) != 0) {</p><p>           killApplication(pkg.applicationInfo.packageName,</p><p>                       pkg.applicationInfo.uid);</p><p>     }</p><p>......</p><p>     /*</p><p>     在此之前，四大组件信息都属于Package的私有财产，现在需要把它们登记注册到PKMS内部的</p><p>     财产管理对象中。这样，PKMS就可对外提供统一的组件信息，而不必拘泥于具体的Package</p><p>     */ </p><p>    synchronized(mPackages) {</p><p>   if ((scanMode&amp;SCAN_MONITOR) != 0) {</p><p>        mAppDirs.put(pkg.mPath, pkg);</p><p>   }</p><p>  mSettings.insertPackageSettingLPw(pkgSetting, pkg);</p><p>   mPackages.put(pkg.applicationInfo.packageName,pkg);</p><p>   //处理该Package中的Provider信息</p><p>   int N =pkg.providers.size();</p><p>   int i;</p><p>   for (i=0;i&lt;N; i++) { </p><p>   PackageParser.Providerp = pkg.providers.get(i);</p><p>   p.info.processName=fixProcessName(</p><p>                               pkg.applicationInfo.processName,</p><p>                  p.info.processName, pkg.applicationInfo.uid);</p><p>    //mProvidersByComponent提供基于ComponentName的Provider信息查询</p><p>    mProvidersByComponent.put(new ComponentName(</p><p>                               p.info.packageName,p.info.name), p);</p><p>             ......</p><p>   }</p><p>   //处理该Package中的Service信息</p><p>   N =pkg.services.size();</p><p>   r = null;</p><p>   for (i=0;i&lt;N; i++) {</p><p>   PackageParser.Service s =pkg.services.get(i);</p><p>   mServices.addService(s);</p><p>   }</p><p>   //处理该Package中的BroadcastReceiver信息</p><p>   N =pkg.receivers.size();</p><p>   r = null;</p><p>   for (i=0;i&lt;N; i++) {</p><p>   PackageParser.Activity a =pkg.receivers.get(i);</p><p>   mReceivers.addActivity(a,"receiver");</p><p>   ......</p><p>   }</p><p>   //处理该Package中的Activity信息</p><p>   N = pkg.activities.size();</p><p>   r =null;</p><p>   for (i=0; i&lt;N; i++) {</p><p>   PackageParser.Activity a =pkg.activities.get(i);</p><p>   mActivities.addActivity(a,"activity");//后续将详细分析该调用</p><p>  }</p><p>   //处理该Package中的PermissionGroups信息</p><p>   N = pkg.permissionGroups.size();</p><p>   ......//permissionGroups处理</p><p>   N =pkg.permissions.size();</p><p>   ......//permissions处理</p><p>   N =pkg.instrumentation.size();</p><p>   ......//instrumentation处理</p><p>   if(pkg.protectedBroadcasts != null) {</p><p>      N = pkg.protectedBroadcasts.size();</p><p>      for(i=0; i&lt;N; i++) {</p><p>        mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i));</p><p>      }</p><p>}</p><p>   ......//Package的私有财产终于完成了公有化改造</p><p>return pkg; </p><p>}</p></div><p>到此这个长达800行的代码就分析完了，下面总结一下Package扫描的流程。</p><h5>（5） scanDirLI函数总结</h5><p>scanDirLI用于对指定目录下的APK文件进行扫描，如图4-7所示为该函数的调用流程。</p><p><img src="images/Center.jpg" alt="Center.jpg" /><br /></p><p>图4-7  scanDirLI工作流程总结</p><p>图4-7比较简单，相关知识无须赘述。读者在自行分析代码时，只要注意区分这两个同名scanPackageLI函数即可。</p><p>扫描完APK文件后，Package的私有财产就充公了。PKMS提供了好几个重要数据结构来保存这些财产，这些数据结构的相关信息如图4-8所示。</p><p><img src="images/Center.jpg" alt="Center.jpg" /><br /></p><p>图4-8  PKMS中重要的数据结构</p><p>图4-8借用UML的类图来表示PKMS中重要的数据结构。每个类图的第一行为成员变量名，第二行为数据类型，第三行为注释说明。</p><h4>3.  扫描非系统Package</h4><p>非系统Package就是指那些不存储在系统目录下的APK文件，这部分代码如下：</p><p>[--&gt;PackageManagerService.java::构造函数第三部分]</p><div><p>           if (!mOnlyCore) {//mOnlyCore用于控制是否扫描非系统Package</p><p>               Iterator&lt;PackageSetting&gt; psit =  </p><p>                            mSettings.mPackages.values().iterator();</p><p>               while (psit.hasNext()) {</p><p>                   ......//删除系统package中那些不存在的APK</p><p>           }</p><p>             mAppInstallDir = new File(dataDir,"app");</p><p>            ......//删除安装不成功的文件及临时文件</p><p>           if (!mOnlyCore) {</p><p>              //在普通模式下，还需要扫描/data/app以及/data/app_private目录 </p><p>              mAppInstallObserver = new AppDirObserver(</p><p>                   mAppInstallDir.getPath(), OBSERVER_EVENTS, false);</p><p>              mAppInstallObserver.startWatching();</p><p>              scanDirLI(mAppInstallDir, 0, scanMode, 0);</p><p>               mDrmAppInstallObserver = newAppDirObserver(</p><p>                   mDrmAppPrivateInstallDir.getPath(), OBSERVER_EVENTS, false);</p><p>              mDrmAppInstallObserver.startWatching();</p><p>              scanDirLI(mDrmAppPrivateInstallDir,            </p><p>                            PackageParser.PARSE_FORWARD_LOCK,scanMode,0);</p><p>           } else {</p><p>               mAppInstallObserver = null;</p><p>               mDrmAppInstallObserver = null;</p><p>      }</p></div><p>结合前述代码，这里总结几个存放APK文件的目录。</p><p>·  系统Package目录包括：/system/frameworks、/system/app和/vendor/app。</p><p>·  非系统Package目录包括：/data/app、/data/app-private。</p><h4>4.  第二阶段工作总结</h4><p>PKMS构造函数第二阶段的工作任务非常繁重，要创建比较多的对象，所以它是一个耗时耗内存的操作。在工作中，我们一直想优化该流程以加快启动速度，例如延时扫描不重要的APK，或者保存Package信息到文件中，然后在启动时从文件中恢复这些信息以减少APK文件读取并解析XML的工作量。但是一直没有一个比较完满的解决方案，原因有很多。比如APK之间有着比较微妙的依赖关系，因此到底延时扫描哪些APK，尚不能确定。另外，笔者感到比较疑惑的一个问题是：对于多核CPU架构，PKMS可以启动多个线程以扫描不同的目录，但是目前代码中还没有寻找到相关的蛛丝马迹。难道此处真的就不能优化了吗？读者如果有更好的解决方案，不妨和大家分享一下。</p><h3>4.3.3  构造函数分析之扫尾工作</h3><p>下面分析PKMS第三阶段的工作，这部分任务比较简单，就是将第二阶段收集的信息再集中整理一次，比如将有些信息保存到文件中，相关代码如下：</p><p>[--&gt;PackageManagerService.java::构造函数]</p><div><p>......</p><p>  mSettings.mInternalSdkPlatform= mSdkVersion;</p><p>  //汇总并更新和Permission相关的信息</p><p>  updatePermissionsLPw(null, null, true, </p><p>                           regrantPermissions,regrantPermissions);</p><p>   //将信息写到package.xml、package.list及package-stopped.xml文件中</p><p>   mSettings.writeLPr();</p><p>   Runtime.getRuntime().gc();</p><p>    mRequiredVerifierPackage= getRequiredVerifierLPr();</p><p>......//PKMS构造函数返回</p><p>}</p></div><p>读者可自行研究以上代码中涉及的几个函数，这里不再赘述。</p><h3>4.3.4  PKMS构造函数总结</h3><p>从流程角度看，PKMS构造函数的功能还算清晰，无非是扫描XML或APK文件，但是其中涉及的数据结构及它们之间的关系却较为复杂。这里有一些建议供读者参考：</p><p>·  理解PKMS构造函数工作的三个阶段及其各阶段的工作职责。</p><p>·  了解PKMS第二阶段工作中解析APK文件的几个关键步骤，可参考图4-7。</p><p>·  了解重点数据结构的名字和大体功能。</p><p>如果对PKMS的分析到此为止，则未免有些太小视它了。下面将分析几个重量级的知识点，期望能带领读者全方位认识PKMS。</p><h2>4.4  APK Installation分析</h2><p>本节将分析APK的安装及相关处理流程，它可能比读者想象得要复杂。</p><p>马上开始我们的行程，故事从adb install开始。</p><h3>4.4.1  adb install分析</h3><p>adb install有多个参数，这里仅考虑最简单的，如adb installframeworktest.apk。adb是一个命令，install是它的参数。此处直接跳到处理install参数的代码：</p><p>[--&gt;commandline.c]</p><div><p>int adb_commandline(int argc, char **argv){</p><p>   ......  </p><p>if(!strcmp(argv[0], "install")) {</p><p>       ......//调用install_app函数处理</p><p>       return install_app(ttype, serial, argc, argv);</p><p>}</p><p>......</p><p>}</p></div><p>install_app函数也在commandline.c中定义，代码如下：</p><p>[--&gt;commandline.c]</p><div><p>int install_app(transport_type transport, char*serial, int argc, char** argv)</p><p>{</p><p>    //要安装的APK现在还在Host机器上，要先把APK复制到手机中。</p><p>   //这里需要设置复制目标的目录，如果安装在内部存储中，则目标目录为/data/local/tmp；</p><p>   //如果安装在SD卡上，则目标目录为/sdcard/tmp。</p><p>    staticconst char *const DATA_DEST = "/data/local/tmp/%s";</p><p>    staticconst char *const SD_DEST = "/sdcard/tmp/%s";</p><p>    constchar* where = DATA_DEST;</p><p>    charapk_dest[PATH_MAX];</p><p>    charverification_dest[PATH_MAX];</p><p>    char*apk_file;</p><p>    char*verification_file = NULL;</p><p>    intfile_arg = -1;</p><p>    int err;</p><p>    int i;</p><p>    for (i =1; i &lt; argc; i++) {</p><p>        if(*argv[i] != '-') {</p><p>           file_arg = i;</p><p>           break;</p><p>        }else if (!strcmp(argv[i], "-i")) {</p><p>            i++;</p><p>        }else if (!strcmp(argv[i], "-s")) {</p><p>           where = SD_DEST; //-s参数指明该APK安装到SD卡上</p><p>        }</p><p>    }</p><p>    ......</p><p>    apk_file= argv[file_arg];</p><p>    ......</p><p>    //获取目标文件的全路径，如果安装在内部存储中，则目标全路径为/data/local/tmp/安装包名，</p><p>    //调用do_sync_push将此APK传送到手机的目标路径</p><p>    err =do_sync_push(apk_file, apk_dest, 1 /* verify APK */);</p><p>    ...... //①4.0新增了一个安装包Verification功能，相关知识稍后分析</p><p>    //②执行pm命令，这个函数很有意思</p><p>    pm_command(transport,serial, argc, argv);</p><p>......</p><p>  cleanup_apk:</p><p>    //③在手机中执行shell rm 命令，删除刚才传送过去的目标APK文件。为什么要删除呢</p><p>   delete_file(transport, serial, apk_dest);</p><p>    returnerr;</p><p>}</p></div><p>以上代码中共有三个关键点，分别是：</p><p>·  4.0新增了APK安装过程中的Verification的功能。其实就是在安装时，把相关信息发送给指定的Verification程序（另外一个APK），由它对要安装的APK进行检查（Verify）。这部分内容在后面分析APK 安装时会介绍。目前，标准代码中还没有从事Verification工作的APK。</p><p>·  调用pm_command进行安装，这是一个比较有意思的函数，稍后对其进行分析。</p><p>·  安装完后，执行shell rm删除刚才传送给手机的APK文件。为什么会删除呢？因为PKMS在安装过程中会将该APK复制一份到/data/app目录下，所以/data/local/tmp下的对应文件就可以删除了。这部分代码在后面也能见到。</p><p>先来分析pm_command命令。为什么说它很有意思呢？</p><h3>4.4.2  pm分析</h3><p>pm_command代码如下：</p><p>[--&gt;commandline.c]</p><div><p>static int pm_command(transport_type transport,char* serial,</p><p>                      int argc, char** argv)</p><p>{</p><p>    charbuf[4096];</p><p>    snprintf(buf,sizeof(buf), "shell:pm");</p><p>  ......//准备参数</p><p>  //发送"shell:pm install 参数"给手机端的adbd</p><p>   send_shellcommand(transport, serial, buf);</p><p>    return0;</p><p>}</p></div><p>手机端的adbd在收到客户端发来的shellpm命令时会启动一个shell，然后在其中执行pm。pm是什么？为什么可以在shell下执行？</p><div><p><strong>提示</strong>读者可以通过adb shell登录到自己手机，然后执行pm，看看会发现什么。</p></div><p>pm实际上是一个脚本，其内容如下：</p><p>[--&gt;pm]</p><div><p># Script to start "pm" on the device,which has a very rudimentary</p><p># shell.</p><p>#</p><p>base=/system</p><p>export CLASSPATH=$base/frameworks/pm.jar</p><p>exec app_process $base/bincom.android.commands.pm.Pm "$@"</p></div><p>在编译system.image时，Android.mk中会将该脚本复制到system/bin目录下。从pm脚本的内容来看，它就是通过app_process执行pm.jar包的main函数。在卷I第4章分析Zygote时，已经介绍了app_process是一个Native进程，它通过创建虚拟机启动了Zygote，从而转变为一个Java进程。实际上，app_process还可以通过类似的方法（即先创建Dalvik虚拟机，然后执行某个类的main函数）来转变成其他Java程序。</p><div><p><strong>注意</strong>Android系统中常用的monkeytest、pm、am等（这些都是脚本文件）都是以这种方式启动的，所以严格地说，app_process才是Android Java进程的老祖宗。</p></div><p>下面来分析pm.java，app_process执行的就是它定义的main函数，它相当于Java进程的入口函数，其代码如下：</p><p>[--&gt;pm.java]</p><div><p>public static void main(String[] args) {</p><p>        newPm().run(args);//创建一个Pm对象，并执行它的run函数</p><p>}</p><p>  //直接分析run函数</p><p>public void run(String[] args) {</p><p>       boolean validCommand = false;</p><p>        ......</p><p>        //获取PKMS的binder客户端</p><p>        mPm= IPackageManager.Stub.asInterface(</p><p>                        ServiceManager.getService("package"));</p><p>        ......</p><p>       mArgs = args;</p><p>       String op = args[0];</p><p>       mNextArg = 1;</p><p>       ......//处理其他命令，这里仅考虑install的处理</p><p>        if("install".equals(op)) {</p><p>           runInstall();</p><p>           return;</p><p>        }</p><p>   ......</p><p>}</p></div><p>接下来分析pm.java的runInstall函数，代码如下：</p><p>[--&gt;pm.java]</p><div><p>private void runInstall() {</p><p>        intinstallFlags = 0;</p><p>       String installerPackageName = null;</p><p> </p><p>       String opt;</p><p>       while ((opt=nextOption()) != null) {</p><p>           if (opt.equals("-l")) {</p><p>               installFlags |= PackageManager.INSTALL_FORWARD_LOCK;</p><p>            } else if (opt.equals("-r")) {</p><p>               installFlags |= PackageManager.INSTALL_REPLACE_EXISTING;</p><p>           } else if (opt.equals("-i")) {</p><p>               installerPackageName = nextOptionData();</p><p>               ...... //参数解析</p><p>           } ...... </p><p>        }</p><p> </p><p>       final Uri apkURI;</p><p>       final Uri verificationURI;</p><p>       final String apkFilePath = nextArg();</p><p>       System.err.println("/tpkg: " + apkFilePath);</p><p>        if(apkFilePath != null) {</p><p>           apkURI = Uri.fromFile(new File(apkFilePath));</p><p>        }......</p><p>        //获取Verification Package的文件位置</p><p>       final String verificationFilePath = nextArg();</p><p>        if(verificationFilePath != null) {</p><p>          verificationURI = Uri.fromFile(new File(verificationFilePath));</p><p>        }else {</p><p>           verificationURI = null;</p><p>        }</p><p>        //创建PackageInstallObserver，用于接收PKMS的安装结果</p><p>       PackageInstallObserver obs = new PackageInstallObserver();</p><p>        try{</p><p>          //①调用PKMS的installPackageWithVerification完成安装</p><p>           mPm.installPackageWithVerification(apkURI, obs, </p><p>                                  installFlags,installerPackageName,</p><p>                                  verificationURI,null);</p><p>    synchronized (obs) {</p><p>      while(!obs.finished) {</p><p>          try{</p><p>                  obs.wait();//等待安装结果</p><p>             } ......</p><p>         }</p><p>         if(obs.result == PackageManager.INSTALL_SUCCEEDED) {</p><p>             System.out.println("Success");//安装成功，打印Success</p><p>         }......//安装失败，打印失败原因</p><p>        } ......</p><p>    }</p></div><p>Pm解析参数后，最终通过PKMS的Binder客户端调用installPackageWithVerification以完成后续的安装工作，所以，下面进入PKMS看看安装到底是怎么一回事。</p><p> </p><h3>4.4.3  installPackageWithVerification函数分析</h3><p>installPackageWithVerification的代码如下：</p><p>[--&gt;PackageManagerService.java::installPackageWithVerification函数]</p><div><p>public void installPackageWithVerification(UripackageURI,</p><p>            IPackageInstallObserverobserver,</p><p>           int flags, String installerPackageName, Uri verificationURI,</p><p>           ManifestDigest manifestDigest) {</p><p>        //检查客户端进程是否具有安装Package的权限。在本例中，该客户端进程是shell</p><p>       mContext.enforceCallingOrSelfPermission(</p><p>               android.Manifest.permission.INSTALL_PACKAGES,null);</p><p>       final int uid = Binder.getCallingUid();</p><p>       final int filteredFlags;</p><p>        if(uid == Process.SHELL_UID || uid == 0) {</p><p>             ......//如果通过shell pm的方式安装，则增加INSTALL_FROM_ADB标志</p><p>           filteredFlags = flags | PackageManager.INSTALL_FROM_ADB;</p><p>        }else {</p><p>           filteredFlags = flags &amp; ~PackageManager.INSTALL_FROM_ADB;</p><p>        }</p><p>        //创建一个Message，code为INIT_COPY，将该消息发送给之前在PKMS构造函数中</p><p>       //创建的mHandler对象，将在另外一个工作线程中处理此消息</p><p>       final Message msg = mHandler.obtainMessage(INIT_COPY);</p><p>        //创建一个InstallParams，其基类是HandlerParams</p><p>       msg.obj = new InstallParams(packageURI, observer, </p><p>                   filteredFlags,installerPackageName,</p><p>                  verificationURI,manifestDigest);</p><p>       mHandler.sendMessage(msg);</p><p>}</p></div><p>installPackageWithVerification函数倒是蛮清闲，简简单单创建几个对象，然后发送INIT_COPY消息给mHandler，就甩手退出了。根据之前在PKMS构造函数中介绍的知识可知，mHandler被绑定到另外一个工作线程（借助ThreadHandler对象的Looper）中，所以该INIT_COPY消息也将在那个工作线程中进行处理。我们马上转战到那。</p><h4>1.  INIT_COPY处理</h4><p>INIT_COPY只是安装流程的第一步。先来看相关代码：</p><p>[--&gt;PackageManagerService.java::handleMesssage]</p><div><p>public void handleMessage(Message msg) {</p><p>  try {</p><p>         doHandleMessage(msg);//调用doHandleMessage函数</p><p>       } ......</p><p> }</p><p> voiddoHandleMessage(Message msg) {</p><p> switch(msg.what) {</p><p>    caseINIT_COPY: {</p><p>      //①这里记录的是params的基类类型HandlerParams，实际类型为InstallParams</p><p>     HandlerParams params = (HandlerParams) msg.obj;</p><p>      //idx为当前等待处理的安装请求的个数</p><p>      intidx = mPendingInstalls.size();</p><p>      if(!mBound) {</p><p>        /*</p><p>        很多读者可能想不到，APK的安装居然需要使用另外一个APK提供的服务，该服务就是</p><p>         DefaultContainerService，由DefaultCotainerService.apk提供，</p><p>         下面的connectToService函数将调用bindService来启动该服务</p><p>        */</p><p>        if(!connectToService()) {</p><p>             return;</p><p>         }else {//如果已经连上，则以idx为索引，将params保存到mPendingInstalls中</p><p>           mPendingInstalls.add(idx, params);</p><p>          }</p><p>        } else {</p><p>           mPendingInstalls.add(idx, params);</p><p>            if(idx == 0) {</p><p>            //如果安装请求队列之前的状态为空，则表明要启动安装</p><p>            mHandler.sendEmptyMessage(MCS_BOUND);</p><p>           }</p><p>         }</p><p>        break;</p><p>        }</p><p>      ......//后续再分析</p></div><p>这里假设之前已经成功启动了DefaultContainerService（以后简称DCS），并且idx为零，所以这是PKMS首次处理安装请求，也就是说，下一个将要处理的是MCS_BOUND消息。</p><div><p><strong>注意</strong>connectToService在调用bindService时会传递一个DefaultContainerConnection类型的对象，以接收服务启动的结果。当该服务成功启动后，此对象的onServiceConnected被调用，其内部也将发送MCS_BOUND消息给mHandler。</p></div><h4>2.  MCS_BOUND处理</h4><p>现在，安装请求的状态从INIT_COPY变成MCS_BOUND了，此时的处理流程时怎样的呢？依然在doHandleMessage函数中，直接从对应的case开始，代码如下：</p><p>[--&gt;PackageManagerService.java::]</p><div><p>......//接doHandleMesage中的switch/case</p><p>case MCS_BOUND: {</p><p>  if(msg.obj != null) {</p><p>     mContainerService= (IMediaContainerService) msg.obj;</p><p>  }</p><p>  if(mContainerService == null) {</p><p>    ......//如果没法启动该service，则不能安装程序</p><p>     mPendingInstalls.clear();</p><p>  } else if(mPendingInstalls.size() &gt; 0) {</p><p>      HandlerParamsparams = mPendingInstalls.get(0);</p><p>      if(params != null) {</p><p>         //调用params对象的startCopy函数，该函数由基类HandlerParams定义</p><p>        if(params.startCopy()) {</p><p>           ......</p><p>            if(mPendingInstalls.size() &gt; 0) {</p><p>               mPendingInstalls.remove(0);//删除队列头</p><p>             }</p><p>          if (mPendingInstalls.size() == 0) {</p><p>            if (mBound) {</p><p>              ......//如果安装请求都处理完了，则需要和Service断绝联系,</p><p>              //通过发送MSC_UNB消息处理断交请求。读者可自行研究此情况的处理流程</p><p>               removeMessages(MCS_UNBIND);</p><p>               Message ubmsg = obtainMessage(MCS_UNBIND);</p><p>               sendMessageDelayed(ubmsg, 10000);</p><p>            }</p><p>            }else {</p><p>              //如果还有未处理的请求，则继续发送MCS_BOUND消息。</p><p>              //为什么不通过一个循环来处理所有请求呢</p><p>              mHandler.sendEmptyMessage(MCS_BOUND);</p><p>             }</p><p>            }</p><p>     } ......</p><p>    break;</p></div><p>MCS_BOUND的处理还算简单，就是调用HandlerParams的startCopy函数。在深入分析前，应先认识一下HandlerParams及相关的对象。</p><h5>（1） HandlerParams和InstallArgs介绍</h5><p>除了HandlerParams家族外，这里提前请出另外一个家族InstallArgs及其成员，如图4-8所示。</p><p><img src="images/Center.jpg" alt="Center.jpg" /><br /></p><p>图4-8  HandlerParams及InstallArgs家族成员</p><p>由图4-8可知：</p><p>·  HandlerParams和InstallArgs均为抽象类。</p><p>·  HandlerParams有三个子类，分别是InstallParams、MoveParams和MeasureParams。其中，InstallParams用于处理APK的安装，MoveParams用于处理某个已安装APK的搬家请求（例如从内部存储移动到SD卡上），MeasureParams用于查询某个已安装的APK占据存储空间的大小（例如在设置程序中得到的某个APK使用的缓存文件的大小）。</p><p>·  对于InstallParams来说，它还有两个伴儿，即InstallArgs的派生类FileInstallArgs和SdInstallArgs。其中，FileInstallArgs针对的是安装在内部存储的APK，而SdInstallArgs针对的是那些安装在SD卡上的APK。</p><p>本节将讨论用于内部存储安装的FileInstallArgs。</p><div><p><strong>提示</strong>读者可以在介绍完MountService后，结合本章知识点，自行研究SdInstallArgs的处理流程。</p></div><p>在前面MCS_BOUND的处理中，首先调用InstallParams的startCopy函数，该函数由其基类HandlerParams实现，代码如下：</p><p>[--&gt;PackageManagerService.java::HandlerParams.startCopy函数]</p><div><p>final boolean startCopy() {</p><p>    booleanres;</p><p>    try {</p><p>    //MAX_RETIRES目前为4，表示尝试4次安装，如果还不成功，则认为安装失败</p><p>    if(++mRetries &gt; MAX_RETRIES) {</p><p>        mHandler.sendEmptyMessage(MCS_GIVE_UP);</p><p>        handleServiceError();</p><p>        return false;</p><p>    } else {</p><p>         handleStartCopy();//①调用派生类的handleStartCopy函数</p><p>         res= true;</p><p>      }</p><p>    } ......</p><p>   handleReturnCode();//②调用派生类的handleReturnCode，返回处理结果</p><p>    returnres;</p><p>}</p></div><p>在上述代码中，基类的startCopy将调用子类实现的handleStartCopy和handleReturnCode函数。下面来看InstallParams是如何实现这两个函数的。</p><h5>（2） InstallParams分析</h5><p>先来看派生类InstallParams的handleStartCopy函数，代码如下：</p><p>[--&gt;PackageManagerService::InstallParams.handleStartCopy]</p><div><p>public void handleStartCopy() throwsRemoteException {</p><p>    int ret= PackageManager.INSTALL_SUCCEEDED;</p><p>    finalboolean fwdLocked = //本书不考虑fwdLocked的情况</p><p>        (flags &amp;PackageManager.INSTALL_FORWARD_LOCK) != 0;</p><p>    //根据adb install的参数，判断安装位置</p><p>    finalboolean onSd = (flags &amp; PackageManager.INSTALL_EXTERNAL) != 0;</p><p>    finalboolean onInt = (flags &amp; PackageManager.INSTALL_INTERNAL) != 0;</p><p>   PackageInfoLite pkgLite = null;</p><p>    if(onInt &amp;&amp; onSd) {</p><p>        //APK不能同时安装在内部存储和SD卡上</p><p>       ret =PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;</p><p>    } elseif (fwdLocked &amp;&amp; onSd) {</p><p>    //fwdLocked的应用不能安装在SD卡上</p><p>      ret =PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;</p><p>    } else {</p><p>       finallong lowThreshold;</p><p>       //获取DeviceStorageMonitorService的binder客户端</p><p>       finalDeviceStorageMonitorService dsm =                            </p><p>             (DeviceStorageMonitorService) ServiceManager.getService(</p><p>                                  DeviceStorageMonitorService.SERVICE);</p><p>       if(dsm == null) {</p><p>         lowThreshold = 0L;</p><p>       }else {</p><p>       //从DSMS查询内部空间最小余量，默认是总空间的10%</p><p>     lowThreshold = dsm.getMemoryLowThreshold();</p><p>     }</p><p>     try {</p><p>        //授权DefContainerService URI读权限</p><p>      mContext.grantUriPermission(DEFAULT_CONTAINER_PACKAGE,</p><p>                  packageURI,Intent.FLAG_GRANT_READ_URI_PERMISSION);</p><p>       //①调用DCS的getMinimalPackageInfo函数，得到一个PackageLite对象</p><p>       pkgLite =mContainerService.getMinimalPackageInfo(packageURI,</p><p>                                   flags,lowThreshold);</p><p>     }finally ......//撤销URI授权</p><p>    //<span>PacakgeLite</span>的recommendedInstallLocation成员变量保存该APK推荐的安装路径</p><p>   int loc =pkgLite.recommendedInstallLocation;</p><p>   if (loc== PackageHelper.RECOMMEND_FAILED_INVALID_LOCATION) {</p><p>         ret= PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;</p><p>   } else if......{</p><p>   } else {</p><p>       //②根据DCS返回的安装路径，还需要调用installLocationPolicy进行检查</p><p>       loc =installLocationPolicy(pkgLite, flags);</p><p>       if(!onSd &amp;&amp; !onInt) {</p><p>          if(loc == PackageHelper.RECOMMEND_INSTALL_EXTERNAL) {</p><p>              flags |= PackageManager.INSTALL_EXTERNAL;</p><p>               flags &amp;=~PackageManager.INSTALL_INTERNAL;</p><p>              } ......//处理安装位置为内部存储的情况</p><p>           }</p><p>       }</p><p>    }</p><p>  //③创建一个安装参数对象，对于安装位置为内部存储的情况，args的真实类型为FileInstallArgs</p><p>    finalInstallArgs args = createInstallArgs(this);</p><p>    mArgs =args;</p><p>    if (ret== PackageManager.INSTALL_SUCCEEDED) {</p><p>        final int requiredUid = mRequiredVerifierPackage == null ? -1</p><p>                      :getPackageUid(mRequiredVerifierPackage);</p><p>        if(requiredUid != -1 &amp;&amp; isVerificationEnabled()) {</p><p>            ......//④待会再讨论verification的处理</p><p>         }else {</p><p>         //⑤调用args的copyApk函数</p><p>         ret= args.copyApk(mContainerService, true);</p><p>      }</p><p>   }</p><p>   mRet =ret;//确定返回值</p><p>}</p></div><p>在以上代码中，一共列出了五个关键点，总结如下：</p><p>·  调用DCS的getMinimalPackageInfo函数，将得到一个<span>PackageLite</span>对象，该对象是一个轻量级的用于描述APK的结构（相比PackageParser.Package来说）。在这段代码逻辑中，主要想取得其recommendedInstallLocation的值。此值表示该APK推荐的安装路径。</p><p>·  调用installLocationPolicy检查推荐的安装路径。例如系统Package不允许安装在SD卡上。</p><p>·  createInstallArgs将根据安装位置创建不同的InstallArgs。如果是内部存储，则返回FileInstallArgs，否则为SdInstallArgs。</p><p>·  在正式安装前，应先对该APK进行必要的检查。这部分代码后续再介绍。</p><p>·  调用InstallArgs的copyApk。对本例来说，将调用FileInstallArgs的copyApk函数。</p><p>下面围绕这五个基本关键点展开分析，其中installLocationPolicy和createInstallArgs比较简单，读者可自行研究。</p><h4>3.  handleStartCopy分析</h4><h5>（1） DefaultContainerService分析</h5><p>首先分析DCS的getMinimalPackageInfo函数，其代码如下：</p><p>[--&gt;DefaultContainerService.java::getMinimalPackageInfo函数]</p><div><p>public PackageInfoLite getMinimalPackageInfo(finalUri fileUri, int flags, </p><p>                                                      longthreshold) {</p><p>   //注意该函数的参数：fileUri指向该APK的文件路径（此时还在/data/local/tmp下）</p><p>  PackageInfoLite ret = new PackageInfoLite();</p><p>   ......</p><p>   Stringscheme = fileUri.getScheme();</p><p>   ......</p><p>   StringarchiveFilePath = fileUri.getPath();</p><p>  DisplayMetrics metrics = new DisplayMetrics();</p><p>  metrics.setToDefaults();</p><p>   //调用PackageParser的parsePackageLite解析该APK文件</p><p>  PackageParser.PackageLite pkg = </p><p>         PackageParser.parsePackageLite(archiveFilePath,0);</p><p>   if (pkg== null) {//解析失败</p><p>   ......//设置错误值</p><p>   returnret;</p><p> }</p><p>  ret.packageName = pkg.packageName;</p><p>  ret.installLocation = pkg.installLocation;</p><p>  ret.verifiers = pkg.verifiers;</p><p>   //调用recommendAppInstallLocation，取得一个合理的安装位置</p><p>  ret.recommendedInstallLocation =</p><p>          recommendAppInstallLocation(pkg.installLocation,archiveFilePath,</p><p>                                           flags, threshold);</p><p>   returnret;</p><p>}</p></div><p>APK可在AndroidManifest.xml中声明一个安装位置，不过DCS除了解析该位置外，还需要做进一步检查，这个工作由recommendAppInstallLocation函数完成，代码如下：</p><p>[--&gt;DefaultContainerService.java::recommendAppInstallLocation函数]</p><div><p>private int recommendAppInstallLocation(intinstallLocation,</p><p>                               StringarchiveFilePath, int flags,long threshold) {</p><p> int prefer;</p><p> booleancheckBoth = false;</p><p> check_inner: {</p><p>   if((flags &amp; PackageManager.INSTALL_FORWARD_LOCK) != 0) {</p><p>        prefer = PREFER_INTERNAL;</p><p>        break check_inner; //根据FOWRAD_LOCK的情况，只能安装在内部存储</p><p>    } elseif ((flags &amp; PackageManager.INSTALL_INTERNAL) != 0) {</p><p>        prefer = PREFER_INTERNAL;</p><p>        break check_inner;</p><p>   } </p><p>   ......//检查各种情况</p><p>  } else if(installLocation == PackageInfo.INSTALL_LOCATION_AUTO) {</p><p>     prefer= PREFER_INTERNAL;//一般设定的位置为AUTO，默认是内部空间</p><p>    checkBoth = true; //设置checkBoth为true</p><p>     breakcheck_inner;</p><p> }</p><p>  //查询settings数据库中的secure表，获取用户设置的安装路径</p><p>  intinstallPreference =</p><p>        Settings.System.getInt(getApplicationContext()</p><p>            .getContentResolver(),</p><p>             Settings.Secure.DEFAULT_INSTALL_LOCATION,</p><p>             PackageHelper.APP_INSTALL_AUTO);</p><p>   if(installPreference == PackageHelper.APP_INSTALL_INTERNAL) {</p><p>       prefer = PREFER_INTERNAL;</p><p>       break check_inner;</p><p>   } else if(installPreference == PackageHelper.APP_INSTALL_EXTERNAL) {</p><p>      prefer= PREFER_EXTERNAL;</p><p>      breakcheck_inner;</p><p>   }</p><p>   prefer =PREFER_INTERNAL;</p><p>  }</p><p>  //判断外部存储空间是否为模拟的，这部分内容我们以后再介绍</p><p>  finalboolean emulated = Environment.isExternalStorageEmulated();</p><p>  final FileapkFile = new File(archiveFilePath);</p><p>  booleanfitsOnInternal = false;</p><p>  if(checkBoth || prefer == PREFER_INTERNAL) {</p><p>      try {//检查内部存储空间是否足够大</p><p>          fitsOnInternal = isUnderInternalThreshold(apkFile, threshold);</p><p>      } ......</p><p>   }</p><p>   booleanfitsOnSd = false;</p><p>   if(!emulated &amp;&amp; (checkBoth || prefer == PREFER_EXTERNAL)) {</p><p>        try{ //检查外部存储空间是否足够大</p><p>         fitsOnSd = isUnderExternalThreshold(apkFile);</p><p>       } ......</p><p>   }</p><p>  if (prefer== PREFER_INTERNAL) {</p><p>      if(fitsOnInternal) {//返回推荐安装路径为内部空间</p><p>        return PackageHelper.RECOMMEND_INSTALL_INTERNAL;</p><p>         }</p><p>    } elseif (!emulated &amp;&amp; prefer == PREFER_EXTERNAL) {</p><p>      if(fitsOnSd) {//返回推荐安装路径为外部空间</p><p>         returnPackageHelper.RECOMMEND_INSTALL_EXTERNAL;</p><p>     }</p><p> }</p><p> </p><p> if(checkBoth) { </p><p>     if(fitsOnInternal) {//如果内部存储满足条件，先返回内部空间</p><p>        return PackageHelper.RECOMMEND_INSTALL_INTERNAL;</p><p>       }else if (!emulated &amp;&amp; fitsOnSd) {</p><p>         return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;</p><p>      }</p><p>  }</p><p>     ...... //到此，前几个条件都不满足，此处将根据情况返回一个明确的错误值</p><p>     returnPackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;</p><p>   }</p><p>}</p></div><p>DCS的getMinimalPackageInfo函数为了得到一个推荐的安装路径做了不少工作，其中，各种安装策略交叉影响。这里总结一下相关的知识点：</p><p>·  APK在AndroidManifest.xml中设置的安装点默认为AUTO，在具体对应时倾向内部空间。</p><p>·  用户在Settings数据库中设置的安装位置。</p><p>·  检查外部存储或内部存储是否有足够空间。</p><h5>（2） InstallArgs的copyApk函数分析</h5><p>至此，我们已经得到了一个合适的安装位置（先略过Verification这一步）。下一步工作就由copyApk来完成。根据函数名可知该函数将完成APK文件的复制工作，此中会有蹊跷吗？来看下面的代码。</p><p>[--&gt;PackageManagerService.java::InstallArgs.copyApk函数]</p><div><p>int copyApk(IMediaContainerService imcs, booleantemp) throws RemoteException {</p><p>   if (temp){</p><p>  /*</p><p>    本例中temp参数为true，createCopyFile将在/data/app下创建一个临时文件。</p><p>    临时文件名为vmdl-随机数.tmp。为什么会用这样的文件名呢？</p><p>    因为PKMS通过Linux的inotify机制监控了/data/app,目录，如果新复制生成的文件名后缀</p><p>    为apk，将触发PKMS扫描。为了防止发生这种情况，这里复制生成的文件才有了</p><p>    如此奇怪的名字</p><p>  */</p><p>   createCopyFile();</p><p>  }</p><p>   FilecodeFile = new File(codeFileName);</p><p>   ......</p><p>  ParcelFileDescriptor out = null;</p><p>   try {</p><p>     out =ParcelFileDescriptor.open(codeFile,</p><p>                            ParcelFileDescriptor.MODE_READ_WRITE);</p><p>           }......</p><p>     int ret= PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;</p><p>     try {</p><p>       mContext.grantUriPermission(DEFAULT_CONTAINER_PACKAGE, </p><p>                   packageURI,Intent.FLAG_GRANT_READ_URI_PERMISSION);</p><p>        //调用DCS的copyResource，该函数将执行复制操作，最终结果是/data/local/tmp</p><p>       //下的APK文件被复制到/data/app下，文件名也被换成vmdl-随机数.tmp</p><p>         ret= imcs.copyResource(packageURI, out);</p><p>    }finally {</p><p>      ......//关闭out，撤销URI授权</p><p>           }</p><p>    returnret;</p><p> }</p></div><p>关于临时文件，这里提供一个示例，如图4-9所示。</p><p><img src="images/Center.jpg" alt="Center.jpg" /><br /></p><p>图4-9  createCopyFile生成的临时文件</p><p>由图4-9可知：/data/app下有两个文件，第一个是正常的APK文件，第二个是createCopyFile生成的临时文件。</p><h4>4.  handleReturnCode分析</h4><p>在HandlerParams的startCopy函数中，handleStartCopy执行完之后，将调用handleReturnCode开展后续工作，代码如下：</p><p>[--&gt;PackageManagerService.java::InstallParams.HandleParams]</p><div><p>void handleReturnCode() {</p><p>       if(mArgs != null) {</p><p>         //调用processPendingInstall函数，mArgs指向之前创建的FileInstallArgs对象</p><p>        processPendingInstall(mArgs, mRet);</p><p>    }</p><p>}</p></div><p>[--&gt;PackageManagerService.java::]</p><div><p>private void processPendingInstall(finalInstallArgs args, </p><p>                                  final intcurrentStatus) {</p><p>   //向mHandler中抛一个Runnable对象</p><p>  mHandler.post(new Runnable() {</p><p>       publicvoid run() {</p><p>        mHandler.removeCallbacks(this);</p><p>         //创建一个PackageInstalledInfo对象，</p><p>       PackageInstalledInfo res = new PackageInstalledInfo();</p><p>       res.returnCode = currentStatus;</p><p>       res.uid = -1;</p><p>       res.pkg = null;</p><p>       res.removedInfo = new PackageRemovedInfo();</p><p>        if(res.returnCode == PackageManager.INSTALL_SUCCEEDED) {</p><p>           //①调用FileInstallArgs的doPreInstall </p><p>           args.doPreInstall(res.returnCode);</p><p>           synchronized (mInstallLock) {</p><p>               //②调用installPackageLI进行安装</p><p>               installPackageLI(args, true, res); </p><p>            }</p><p>          //③调用FileInstallArgs的doPostInstall </p><p>         args.doPostInstall(res.returnCode);</p><p>        }</p><p>       final boolean update = res.removedInfo.removedPackage != null;</p><p>       boolean doRestore = (!update&amp;&amp; res.pkg != null &amp;&amp;</p><p>                    res.pkg.applicationInfo.backupAgentName!= null);</p><p>       int token;//计算一个ID号</p><p>        if(mNextInstallToken &lt; 0) mNextInstallToken = 1;</p><p>            token = mNextInstallToken++;</p><p>            //创建一个PostInstallData对象</p><p>            PostInstallData data = new PostInstallData(args, res);</p><p>           //保存到mRunningInstalls结构中，以token为key</p><p>           mRunningInstalls.put(token, data);</p><p>           if (res.returnCode ==PackageManager.INSTALL_SUCCEEDED &amp;&amp; doRestore) </p><p>             {</p><p>                  ......//备份恢复的情况暂时不考虑</p><p>            }</p><p>           if(!doRestore) {</p><p>            //④抛一个POST_INSTALL消息给mHandler进行处理</p><p>            Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0);</p><p>            mHandler.sendMessage(msg);</p><p>           }</p><p>        }</p><p>        });</p><p>}</p></div><p>由上面代码可知，handleReturnCode主要做了4件事情：</p><p>·  调用InstallArgs的doPreInstall函数，在本例中是FileInstallArgs的doPreInstall函数。</p><p>·  调用PKMS的installPackageLI函数进行APK安装，该函数内部将调用InstallArgs的doRename对临时文件进行改名。另外，还需要扫描此APK文件。此过程和之前介绍的“扫描系统Package”一节的内容类似。至此，该APK中的私有财产就全部被登记到PKMS内部进行保存了。</p><p>·  调用InstallArgs的doPostInstall函数，在本例中是FileInstallArgs的doPostInstall函数。</p><p>·  此时，该APK已经安装完成（不论失败还是成功），继续向mHandler抛送一个POST_INSTALL消息，该消息携带一个token，通过它可从mRunningInstalls数组中取得一个PostInstallData对象。</p><div><p><strong>提示</strong>对于FileInstallArgs来说，其doPreInstall和doPostInstall都比较简单，读者可自行阅读相关代码。另外，读者也可自行研究PKMS的installPackageLI函数。</p></div><p>这里介绍一下FileInstallArgs的doRename函数，它的功能是将临时文件改名，最终的文件的名称一般为“包名-数字.apk”。其中，数字是一个index，从1开始。读者可参考图4-9中/data/app目录下第一个文件的文件名。</p><h4>5.  POST_INSTALL处理</h4><p>现在需要处理POST_INSTALL消息，因为adb install还等着安装结果呢。相关代码如下：</p><p>[--&gt;PackageManagerService.java::doHandleMessage函数]</p><div><p>......//接前面的switch/case</p><p>case POST_INSTALL: {</p><p>  PostInstallData data = mRunningInstalls.get(msg.arg1);</p><p> mRunningInstalls.delete(msg.arg1);</p><p>  booleandeleteOld = false;</p><p> </p><p>  if (data!= null) {</p><p>      InstallArgs args = data.args;</p><p>      PackageInstalledInfo res = data.res;</p><p>       if(res.returnCode == PackageManager.INSTALL_SUCCEEDED) {</p><p>           res.removedInfo.sendBroadcast(false, true);</p><p>           Bundle extras = new Bundle(1);</p><p>           extras.putInt(Intent.EXTRA_UID, res.uid);</p><p>           final boolean update = res.removedInfo.removedPackage != null;</p><p>           if (update) {</p><p>                extras.putBoolean(Intent.EXTRA_REPLACING, true);</p><p>           }</p><p>           //发送PACKAGE_ADDED广播 </p><p>           sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,</p><p>                    res.pkg.applicationInfo.packageName,extras, null, null);</p><p>           if (update) {</p><p>           /*</p><p>           如果是APK升级，那么发送PACKAGE_REPLACE和MY_PACKAGE_REPLACED广播。</p><p>          二者不同之处在于PACKAGE_REPLACE将携带一个extra信息</p><p>         */</p><p>       }</p><p>      Runtime.getRuntime().gc();</p><p>       if(deleteOld) {</p><p>         synchronized (mInstallLock) {</p><p>           //调用FileInstallArgs的doPostDeleteLI进行资源清理</p><p>           res.removedInfo.args.doPostDeleteLI(true);</p><p>            }</p><p>        }</p><p>      if(args.observer != null) {</p><p>      try {</p><p>          // 向pm通知安装的结果</p><p>        args.observer.packageInstalled(res.name, res.returnCode);</p><p>      } ......</p><p>} break;</p></div><p> </p><h3>4.4.4  APK 安装流程总结</h3><p>没想到APK的安装流程竟然如此复杂，其目的无非是让APK中的私人财产公有化。相比之下，在PKMS构造函数中进行公有化改造就非常简单。另外，如果考虑安装到SD卡的处理流程，那么APK的安装将会更加复杂。</p><p>这里要总结APK安装过程中的几个重要步骤，如图4-10所示。</p><p><img src="images/Center.jpg" alt="Center.jpg" /><br /></p><p>图4-10  APK安装流程</p><p>图4-10中列出以下内容：</p><p>·  安装APK到内部存储空间这一工作流程涉及的主要对象包括：PKMS、DCS、InstallParams和FileInstallArgs。</p><p>·  此工作流程中每个对象涉及到的关键函数。</p><p>·  对象之间的调用通过虚线表达，调用顺序通过①②③等标明。</p><h3>4.4.5  Verification介绍</h3><p>Verification功能的出现将打乱图4-10的工作流程，所以这部分内容要放在最后来介绍。其代码在InstallParams的handleStartCopy中，如下所示：</p><p>[--&gt;PackageManagerService.java::InstallParams.handleStartCopy函数]</p><div><p>  ......//此处已经获得了合适的安装位置</p><p>  finalInstallArgs args = createInstallArgs(this);</p><p>  mArgs =args;</p><p>if (ret == PackageManager.INSTALL_SUCCEEDED) {</p><p>    final int requiredUid =mRequiredVerifierPackage == null ? -1</p><p>                        :getPackageUid(mRequiredVerifierPackage);</p><p>  if (requiredUid != -1 &amp;&amp;isVerificationEnabled()) {</p><p>     //创建一个Intent，用于查找满足条件的广播接收者</p><p>   finalIntent verification = new</p><p>                    Intent(Intent.ACTION_PACKAGE_NEEDS_VERIFICATION);</p><p>   verification.setDataAndType(packageURI, PACKAGE_MIME_TYPE);</p><p>   verification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</p><p>    //查找满足Intent条件的广播接收者</p><p>    finalList&lt;ResolveInfo&gt; receivers = queryIntentReceivers(</p><p>               verification,null,PackageManager.GET_DISABLED_COMPONENTS);</p><p>    // verificationId为当前等待Verification的安装包个数</p><p>    finalint verificationId = mPendingVerificationToken++;</p><p>   //设置Intent的参数，例如要校验的包名</p><p>    verification.putExtra(PackageManager.EXTRA_VERIFICATION_ID,</p><p>                              VerificationId);</p><p>    verification.putExtra(</p><p>                            PackageManager.EXTRA_VERIFICATION_INSTALLER_PACKAGE,</p><p>                            installerPackageName);</p><p>  verification.putExtra(</p><p>                   PackageManager.EXTRA_VERIFICATION_INSTALL_FLAGS,flags);</p><p>   if(verificationURI != null) {</p><p>     verification.putExtra(PackageManager.EXTRA_VERIFICATION_URI,</p><p>                                verificationURI);</p><p>    }</p><p>  finalPackageVerificationState verificationState = new</p><p>                       PackageVerificationState(requiredUid,args);</p><p>  //将上面创建的PackageVerificationState保存到mPendingVerification中</p><p> mPendingVerification.append(verificationId, verificationState);</p><p>  //筛选符合条件的广播接收者 </p><p>  finalList&lt;ComponentName&gt; sufficientVerifiers =</p><p>                   matchVerifiers(pkgLite,receivers,verificationState);</p><p>  if (sufficientVerifiers != null) {</p><p>      finalint N = sufficientVerifiers.size();</p><p>      ......</p><p>      for(int i = 0; i &lt; N; i++) {</p><p>       finalComponentName verifierComponent = sufficientVerifiers.get(i);</p><p>       final Intent sufficientIntent = newIntent(verification);</p><p>       sufficientIntent.setComponent(verifierComponent);</p><p>       //向校验包发送广播</p><p>       mContext.sendBroadcast(sufficientIntent);</p><p>       }</p><p>    }</p><p> }</p><p>   //除此之外，如果在执行adb install的时候指定了校验包，则需要向其单独发送校验广播</p><p>   finalComponentName requiredVerifierComponent =</p><p>                        matchComponentForVerifier(mRequiredVerifierPackage,</p><p>                       receivers);</p><p>   if (ret == PackageManager.INSTALL_SUCCEEDED</p><p>        &amp;&amp;mRequiredVerifierPackage != null) {</p><p>      verification.setComponent(requiredVerifierComponent);</p><p>      mContext.sendOrderedBroadcast(verification,</p><p>      android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,</p><p>           new BroadcastReceiver() {</p><p>           //调用sendOrderdBroadcast，并传递一个BroadcastReceiver，该对象将在</p><p>          //广播发送的最后被调用。读者可参考sendOrderdBroadcast的文档说明</p><p>           public void onReceive(Context context, Intent intent) {</p><p>            final Message msg =mHandler.obtainMessage(</p><p>                      CHECK_PENDING_VERIFICATION); </p><p>            msg.arg1 = verificationId;</p><p>            //设置一个超时执行时间，该值来自Settings数据库的secure表，默认为60秒</p><p>            mHandler.sendMessageDelayed(msg, getVerificationTimeout());</p><p>           }</p><p>         },null, 0, null, null);</p><p>           mArgs = null;</p><p>        }</p><p>    }......//不用做Verification的流程</p></div><p>PKMS的Verification工作其实就是收集安装包的信息，然后向对应的校验者发送广播。但遗憾的是，当前Android中还没有能处理Verification的组件。</p><p>另外，该组件处理完Verification后，需要调用PKMS的verifyPendingInstall函数，以通知校验结果。</p><h2>4.5  queryIntentActivities分析</h2><p>PKMS除了负责Android系统中Package的安装、升级、卸载外，还有一项很重要的职责，就是对外提供统一的信息查询功能，其中包括查询系统中匹配某Intent的Activities、BroadCastReceivers或Services等。本节将以查询匹配某Intent的Activities为例，介绍PKMS在这方便提供的服务。</p><p>正式分析queryIntentActivities之前，先来认识一下Intent及IntentFilter。</p><h3>4.5.1  Intent及IntentFilter介绍</h3><h4>1.  Intent介绍</h4><p>Intent中文是“意图”的意思，它是Android系统中一个很重要的概念，其基本思想来源于对日常生活及行为的高度抽象。我们结合用人单位招聘的例子介绍Intent背后的思想。</p><p>·  假设某用人单位现需招聘人员完成某项工作。该单位首先其需求发给猎头公司。</p><p>·  猎头公司从其内部的信息库中查找合适的人选。猎头公司除了考虑用人单位的需求外，还需要考虑求职者本身的要求，例如有些求职者对工作地点、加班等有要求。</p><p>·  二者匹配后，就会得到满足要求的求职者。之后用人单位将工作交给满足条件的人员来完成。</p><p>在现实生活中，用人单位还需和求职者进行一系列其他交互工作，例如面试、签订合同之类。但是从完成工作的角度来看，只要把工作任务交给满足要求的求职者去做即可，中间的系列行为和工作任务本身没有太大关系。因此，Android并未将这部分内容抽象化。</p><p>意图，是一个非常抽象的概念，在编码设计中，如何将它实例化呢？Android系统明确指定的一个Intent可由两方面属性来衡量。</p><p>·  主要属性：包括Action和Data。其中Action用于表示该Intent所表达的动作意图、Data用于表示该Action所操作的数据。</p><p>·  次要属性：包括Category、Type、Component和Extras。其中Category表示类别，Type表示数据的MIME类型，Component可用于指定特定的Intent响应者（例如指定广播接收者为某Package的某个BroadcastReceiver），Extras用于承载其他的信息。</p><p>如果Intent是一份用工需求表，那么上述信息就是该表的全部可填项。在实际使用中，可根据需要填写该表的内容。</p><p>当这份需求表传给猎头公司后，猎头公司就根据该表所填写的内容，进一步对Intent进行分类。</p><p>·  Explicit Intents：这类Intent明确指明了要找哪些人。在代码中通过setComponent或setClass来锁定目标对象。处理这种Intent，工作就很轻松了。</p><p>·  Implicit Intents：这一类Intents只标明了工作内容，而没有指定具体人名。对于这类意图，猎头公司不得不做一系列复杂的工作才能找到满足用人单位需求的人才。</p><p>Intent就先介绍到这里。下面来看在这次招聘过程中求职者填写的信息。</p><h4>2.  IntentFilter介绍</h4><p>求职方需要填写IntentFilter来表达自己的诉求。Andorid规定了3项内容.</p><p>·  Action：求职方支持的Intent动作（和Intent中的Action对应）。</p><p>·  Category：求职方支持的Intent种类（和Intent的Category对应）。</p><p>·  Data：求职方支持的Intent 数据（和Intent的Data对应，包括URI和MIME类型）。</p><p>至此，猎头公司既有了需求，又有了求职者的信息，马上要做的工作就是匹配查询。在Android中，该工作被称为Intent Resolution。由于现在及未来人才都是最宝贵的资源，因此猎头公司在做匹配工作时，将以Intent Filter列出的3项内容为参考标准，具体步骤如下：</p><p>·  首先匹配IntentFilter的Action，如果Intent设置的Action不满足IntentFilter的Action，则匹配失败。如果IntentFilter未设定Action，则匹配成功。</p><p>·  然后检查IntentFilter的Category，匹配方法同Action的匹配，唯一有些例外的是Category为CATEGORY_DEFAULT的情况。</p><p>·  最后检查Data。Data的匹配过程比较繁琐，因为它和IntentFilter设置的Data内容有关，见接下来的介绍。</p><p>IntentFilter中的Data可以包括两个内容。</p><p>·  URI：完整格式为“scheme://host:port/path”，包含4个部分，scheme、host、port和path。其中host和port合起来标示URI authority，用于指明服务器的网络地址（IP加端口号）。由于URI最多可包含,4个部分，因此要根据情况相应部分做匹配检查。</p><p>·  Date type：指定数据的MIME类型</p><p>要特别注意的是，URI中也可以携带数据的类型信息，所以在匹配过程中，还需要考虑URI中指定的数据类型。</p><div><p><strong>提示</strong>关于具体的匹配流程，请读者务必阅读SDK docs/guide/topics/intents/intents-filters.html中的说明。</p></div><h3>4.5.2  Activity信息的管理</h3><p>前面在介绍PKMS扫描APK时提到，PKMS将解析得到的Package私有的Activity信息加入到自己的数据结构mActivities中保存。先来回顾一下代码： </p><p>[--&gt;PacakgeManagerService.java::scanPackageLI函数]</p><div><p>     ......//此时APK文件已经解析完成</p><p>     N =pkg.activities.size();//取出该APK中包含的Activities信息</p><p>     r =null;</p><p>     for (i=0; i&lt;N; i++) {</p><p>        PackageParser.Activity a = pkg.activities.get(i);</p><p>        a.info.processName = fixProcessName(pkg.applicationInfo.processName,</p><p>                                     a.info.processName,pkg.applicationInfo.uid);</p><p>         mActivities.addActivity(a,"activity");//①加到mActivities中保存</p><p> }</p></div><p>上面的代码中有两个比较重要的数据结构，如图4-11所示。</p><p><img src="images/Center.jpg" alt="Center.jpg" /><br /></p><p>图4-11  相关数据结构示意图</p><p>结合代码，由图4-11可知：</p><p>·  mActivities为ActivityIntentResolver类型，是PKMS的成员变量，用于保存系统中所有与Activity相关的信息。此数据结构内部有一个mActivities变量，它以ComponetName为Key，保存PackageParser.Activity对象</p><p>·  从APK中解析得到的所有和Activity相关的信息（包括在XML中声明的IntentFilter标签）都由PacakgeParser.Activity来保存。</p><p>前面代码中调用addActivity函数完成了私有信息的公有化。addActivity函数的代码如下：</p><p>[--&gt;PacakgeManagerService.java::ActivityIntentResolver.addActivity]</p><div><p>public final voidaddActivity(PackageParser.Activity a, String type) {</p><p>     finalboolean systemApp = isSystemApp(a.info.applicationInfo);</p><p>     //将Component和Activity保存到mActivities中</p><p>    mActivities.put(a.getComponentName(), a);</p><p>     finalint NI = a.intents.size();</p><p>     for(int j=0; j&lt;NI; j++) {</p><p>     //ActivityIntentInfo存储的就是XML中声明的IntentFilter信息</p><p>    PackageParser.ActivityIntentInfo intent = a.intents.get(j);</p><p>     if(!systemApp &amp;&amp; intent.getPriority() &gt; 0 &amp;&amp;"activity".equals(type)) {</p><p>          //非系统APK的priority必须为0。后续分析中将介绍priority的作用</p><p>          intent.setPriority(0);</p><p>        }</p><p>         addFilter(intent);//接下来将分析这个函数</p><p>      }</p><p> } </p></div><p>下面来分析addFilter函数，这里涉及较多的复杂数据结构，代码如下：</p><p>[--&gt;IntentResolver.java::IntentResolver.addFilter]</p><div><p>public void addFilter(F f) {</p><p>        ......</p><p>       mFilters.add(f);//mFilters保存所有IntentFilter信息</p><p>       //除此之外，为了加快匹配工作的速度，还需要分类保存IntentFilter信息</p><p>       //下边register_xxx函数的最后一个参数用于打印信息</p><p>        intnumS = register_intent_filter(f, f.schemesIterator(),</p><p>                         mSchemeToFilter,"      Scheme: ");</p><p>        intnumT = register_mime_types(f, "     Type: ");</p><p>        if(numS == 0 &amp;&amp; numT == 0) {</p><p>           register_intent_filter(f, f.actionsIterator(),</p><p>                           mActionToFilter,"      Action: ");</p><p>        }</p><p>        if(numT != 0) {</p><p>           register_intent_filter(f, f.actionsIterator(),</p><p>                   mTypedActionToFilter, "     TypedAction: ");</p><p>        }</p><p> }</p></div><p>正如代码注释中所说，为了加快匹配工作的速度，这里使用了泛型编程并定义了较多的成员变量。下面总结一下这些变量的作用（注意，除mFilters为HashSet&lt;F&gt;类型外，其他成员变量的类型都是HashMap&lt;String, ArrayList&lt;F&gt;&gt;，其中F为模板参数）。</p><p>·  mSchemeToFilter：用于保存URI中与schema相关的IntentFilter信息。</p><p>·  mActionToFilter：用于保存仅设置Action条件的IntentFilter信息。</p><p>·  mTypedActionToFilter：用于保存既设置了Action又设置了Data的MIME类型的IntentFilter信息。</p><p>·  mFilters：用于保存所有IntentFilter信息</p><p>·  mWildTypeToFilter：用于保存设置了Data类型类似“image/*”的IntentFilter，但是设置MIME类型类似“Image/jpeg”的不算在此类。</p><p>·  mTypeToFilter：除了包含mWildTypeToFilter外，还包含那些指明了Data类型为确定参数的IntentFilter信息，例如“image/*”和”image/jpeg“等都包含在mTypeToFilter中。</p><p>·  mBaseTypeToFilter：包含MIME中Base 类型的IntentFilter信息，但不包括Sub type为“*”的IntentFilter。</p><p>不妨举个例子来说明这些变量的用法。</p><p>假设，在XML中声明一个IntentFilter，代码如下：</p><div><p>&lt;intent-filter android:label="test"&gt;</p><p>   &lt;actionandroid:name="android.intent.action.VIEW" /&gt;</p><p>   dataandroid:mimeType="audio/*" android:scheme="http"</p><p> &lt;/intent-filter&gt;</p></div><p>那么：</p><p>·  在mTypedActionToFilter中能够以“android.intent.action.VIEW”为key找到该IntentFilter。</p><p>·  在mWildTypeToFilter和mTypeToFilter中能够以“audio”为key找到该IntentFilter。</p><p>·  在mSchemeToFilter中能够以”http“为key找到该IntentFilter。</p><p>下面来分析Intent匹配查询工作。</p><h3>4.5.2  Intent 匹配查询分析</h3><h4>1.  客户端查询</h4><p>客户端通过ApplicationPackageManager输出的queryIntentActivities函数向PKMS发起一次查询请求，代码如下：</p><p>[--&gt;ApplicationPackageManager.java::queryIntentActivities]</p><div><p>public List&lt;ResolveInfo&gt;queryIntentActivities(Intent intent, int flags) {</p><p>   try {</p><p>           return mPM.queryIntentActivities(</p><p>               intent,//下面这句话很重要</p><p>               intent.resolveTypeIfNeeded(mContext.getContentResolver()),</p><p>               flags);</p><p>        }......</p><p>}</p></div><p>如果Intent的Data包含一个URI，那么就需要查询该URI的提供者（即ContentProvider）以取得该数据的数据类型。读者可自行阅读resolveTypeIfNeeded函数的代码。</p><p>另外，flags参数目前有3个可选值，分别是MATCH_DEFAULT_ONLY、GET_INTENT_FILTERS和GET_RESOLVED_FILTER。详细信息读者可查询SDK相关文档。</p><p>下面来看PKMS对匹配查询的处理。</p><h4>2.  queryIntentActivities分析</h4><p>该函数代码如下：</p><p>[--&gt;PacakgeManagerService.java::queryIntentActivities]</p><div><p>public List&lt;ResolveInfo&gt;queryIntentActivities(Intent intent,</p><p>                                  String resolvedType, int flags) {</p><p>       final ComponentName comp = intent.getComponent();</p><p>        if(comp != null) {</p><p>            //Explicit的Intents，直接根据component得到对应的ActivityInfo</p><p>           final List&lt;ResolveInfo&gt; list = new ArrayList&lt;ResolveInfo&gt;(1);</p><p>           final ActivityInfo ai = getActivityInfo(comp, flags);</p><p>           if (ai != null) {</p><p>               final ResolveInfo ri = new ResolveInfo();</p><p>               //ResovlerInfo的activityInfo指向查询得到的ActivityInfo</p><p>               ri.activityInfo = ai; </p><p>               list.add(ri);</p><p>           }</p><p>           return list;</p><p>        }</p><p> </p><p>       synchronized (mPackages) {</p><p>           final String pkgName = intent.getPackage();</p><p>           if (pkgName == null) {</p><p>                        //Implicit Intents，我们重点分析此中情况</p><p>               return mActivities.queryIntent(intent, resolvedType, flags);</p><p>           }</p><p>            //Intent指明了PackageName，比Explicit Intents情况差一点</p><p>           final PackageParser.Package pkg = mPackages.get(pkgName);</p><p>           if (pkg != null) {</p><p>               //其实是从该Package包含的Activities中进行匹配查询</p><p>               return mActivities.queryIntentForPackage(intent, resolvedType,</p><p>                                           flags, pkg.activities);</p><p>           }</p><p>           return new ArrayList&lt;ResolveInfo&gt;();</p><p>        }</p><p>    }</p></div><p>上边代码分三种情况：</p><p>·  如果Intent指明了Component，则直接查询该Component对应的ActivityInfo。</p><p>·  如果Intent指明了Package名，则根据Package名找到该Package，然后再从该Package包含的Activities中进行匹配查询。</p><p>·  如果上面条件都不满足，则需要在全系统范围内进行匹配查询，这就是queryIntent的工作。</p><p>queryIntent函数的代码如下：</p><div><p>public List&lt;ResolveInfo&gt; queryIntent(Intentintent, String resolvedType,</p><p>                                            intflags) {</p><p>    mFlags =flags;</p><p>   //调用基类的queryIntent函数</p><p>   returnsuper.queryIntent(intent, resolvedType,</p><p>               (flags&amp;PackageManager.MATCH_DEFAULT_ONLY) != 0);</p><p> }</p></div><p>[--&gt;IntentResolver.java::queryIntent]</p><div><p>public List&lt;R&gt; queryIntent(Intent intent,String resolvedType,</p><p>                             booleandefaultOnly) {</p><p>  Stringscheme = intent.getScheme();</p><p> ArrayList&lt;R&gt; finalList = new ArrayList&lt;R&gt;();</p><p> //最多有四轮匹配工作要做</p><p> ArrayList&lt;F&gt; firstTypeCut = null;</p><p> ArrayList&lt;F&gt; secondTypeCut = null;</p><p> ArrayList&lt;F&gt; thirdTypeCut = null;</p><p> ArrayList&lt;F&gt; schemeCut = null;</p><p> //下面将设置各轮校验者</p><p> if(resolvedType != null) {</p><p>     intslashpos = resolvedType.indexOf('/');</p><p>      if(slashpos &gt; 0) {</p><p>         final String baseType = resolvedType.substring(0, slashpos);</p><p>          if (!baseType.equals("*")) {</p><p>               if (resolvedType.length() != slashpos+2</p><p>                   || resolvedType.charAt(slashpos+1) != '*') {</p><p>                       firstTypeCut =mTypeToFilter.get(resolvedType);</p><p>                       secondTypeCut =mWildTypeToFilter.get(baseType);</p><p>                   }......//略去一部分内容</p><p>           }</p><p>        }</p><p> </p><p>      if(scheme != null) {</p><p>           schemeCut = mSchemeToFilter.get(scheme);</p><p>        }</p><p>      if(resolvedType == null &amp;&amp; scheme == null &amp;&amp; intent.getAction()!= null)</p><p>      {</p><p>        //看来action的filter优先级最低</p><p>       firstTypeCut = mActionToFilter.get(intent.getAction());</p><p>      }</p><p>   //FastImmutableArraySet是一种特殊的数据结构，用于保存该Intent中携带的</p><p>   //Category相关的信息。</p><p>   FastImmutableArraySet&lt;String&gt;categories = getFastIntentCategories(intent);</p><p>    if(firstTypeCut != null) {</p><p>     //匹配查询，第一轮过关斩将</p><p>     buildResolveList(intent, categories, debug, defaultOnly,</p><p>             resolvedType, scheme, firstTypeCut,finalList);</p><p>    }</p><p>    if(secondTypeCut != null) {</p><p>        buildResolveList(intent, categories, debug, defaultOnly,</p><p>                   resolvedType, scheme, secondTypeCut, finalList);</p><p>     }</p><p>    if(thirdTypeCut != null) {</p><p>        buildResolveList(intent, categories, debug, defaultOnly,</p><p>                   resolvedType, scheme, thirdTypeCut, finalList);</p><p>     }</p><p>    if(schemeCut != null) {</p><p>        //生成符合schemeCut条件的finalList</p><p>        buildResolveList(intent, categories, debug, defaultOnly,</p><p>                   resolvedType, scheme, schemeCut, finalList);</p><p>    }</p><p>   //将匹配结果按Priority的大小排序</p><p>   sortResults(finalList);</p><p>    returnfinalList;</p><p>}</p></div><p>在以上代码中设置了最多四轮匹配关卡，然后逐一执行匹配工作。具体的匹配代码由buildResolveList完成，无非是一项查找工作而已。此处就不再深究细节了，建议读者在研究代码时以目的为导向，不宜深究其中的数据结构。</p><h3>4.5.3 queryIntentActivities总结</h3><p>本节分析了queryIntentActivities函数的实现，其功能很简单，就是进行Intent匹配查询。一路走来，相信读者也感觉到旅程并不轻松，主要原因是涉及的数据结构较多，让人有些头晕。这里，再次建议读者不要在数据结构上花太多时间，最好结合SDK中的文档说明来分析相关代码。</p><h2>4.6  installd及UserManager介绍</h2><h3>4.6.1  installd介绍</h3><p>在前面对PKMS构造函数分析时介绍过一个Installer类型的对象mInstaller，它通过socket和后台服务installd交互，以完成一些重要操作。这里先回顾一下PKMS中mInstaller的调用方法：</p><div><p>mInstaller = new Installer();//创建一个Installer对象</p><p>//对某个APK文件进行dexopt优化</p><p>mInstaller.dexopt(paths[i], Process.SYSTEM_UID,true);</p><p>//扫描完系统Package后，调用moveFiles函数</p><p>mInstaller.moveFiles();</p><p>//当存储空间不足时，调用该函数清理存储空间</p><p>mInstaller.freeCache(freeStorageSize);</p></div><p>Installer的种种行为都和其背后的installd有关。下面来分析installd。</p><h4>1.  installd概貌</h4><p>installd是一个native进程，代码非常简单，其功能就是启动一个socket，然后处理来自Installer的命令，其代码如下：</p><p>[--&gt;installd.c]</p><div><p>int main(const int argc, const char *argv[]) {</p><p>    charbuf[BUFFER_MAX];</p><p>    structsockaddr addr;</p><p>   socklen_t alen;</p><p>    intlsocket, s, count;</p><p>    //</p><p>  if (初始化全局变量,如果失败则退出) {</p><p>    initialize_globals();</p><p>    initialize_directories();</p><p>        ......</p><p>    }</p><p>    ......</p><p>    lsocket= android_get_control_socket(SOCKET_PATH);</p><p>   </p><p>   listen(lsocket, 5);</p><p>   fcntl(lsocket, F_SETFD, FD_CLOEXEC);</p><p> </p><p>    for (;;){</p><p>        alen= sizeof(addr);</p><p>        s =accept(lsocket, &amp;addr, &amp;alen);</p><p>       fcntl(s, F_SETFD, FD_CLOEXEC);</p><p>        for(;;) {</p><p>           unsigned short count;</p><p>           readx(s, &amp;count, sizeof(count));</p><p>           //执行installer发出的命令，具体解释见下文</p><p>            execute(s, buf);</p><p>        }</p><p>       close(s);</p><p>    }</p><p> </p><p>    return0;</p><p>}</p></div><p>installd支持的命令及参数信息都保存在数据结构cmds中，代码如下：</p><p>[--&gt;installd.c]</p><div><p>struct cmdinfo cmds[] = {//第二个变量是参数个数，第三个参数是命令响应函数</p><p>    {"ping",                 0,do_ping },</p><p>    {"install",              3,do_install },</p><p>    {"dexopt",               3,do_dexopt },</p><p>    {"movedex",              2,do_move_dex },</p><p>    {"rmdex",                1,do_rm_dex },</p><p>    {"remove",               2,do_remove },</p><p>    {"rename",               2, do_rename },</p><p>    {"freecache",            1,do_free_cache },</p><p>    {"rmcache",              1,do_rm_cache },</p><p>    {"protect",              2,do_protect },</p><p>    {"getsize",              4,do_get_size },</p><p>    {"rmuserdata",           2,do_rm_user_data },</p><p>    {"movefiles",            0,do_movefiles },</p><p>    {"linklib",              2,do_linklib },</p><p>    {"unlinklib",            1,do_unlinklib },</p><p>    {"mkuserdata",           3,do_mk_user_data },</p><p>    {"rmuser",               1,do_rm_user },</p><p>};</p></div><p>下面来分析相关的几个命令。</p><h4>2.  dexOpt命令分析</h4><p>PKMS在需要对一个APK或jar包做dex优化时，会发送dexopt命令给installd，相应的处理函数为do_dexopt，代码如下：</p><p>[--&gt;installd.c]</p><div><p>static int do_dexopt(char **arg, charreply[REPLY_MAX])</p><p>{</p><p>     returndexopt(arg[0], atoi(arg[1]), atoi(arg[2]));</p><p>}</p></div><p>[--&gt;commands.c]</p><div><p>int dexopt(const char *apk_path, uid_t uid, intis_public)</p><p>{</p><p>    structutimbuf ut;</p><p>    structstat apk_stat, dex_stat;</p><p>    chardex_path[PKG_PATH_MAX];</p><p>    chardexopt_flags[PROPERTY_VALUE_MAX];</p><p>    char*end;</p><p>    int res,zip_fd=-1, odex_fd=-1;</p><p>    ......</p><p>    //取出系统级的dexopt_flags参数</p><p>   property_get("dalvik.vm.dexopt-flags", dexopt_flags,"");</p><p> </p><p>   strcpy(dex_path, apk_path);</p><p>    end =strrchr(dex_path, '.');</p><p>    if (end!= NULL) {</p><p>       strcpy(end, ".odex");</p><p>        if(stat(dex_path, &amp;dex_stat) == 0) {</p><p>           return 0;</p><p>        }</p><p>    }</p><p>    //得到一个字符串，用于描述dex文件名，位于/data/dalvik-cache/下</p><p>    if(create_cache_path(dex_path, apk_path)) {</p><p>       return -1;</p><p>    }</p><p> </p><p>   memset(&amp;apk_stat, 0, sizeof(apk_stat));</p><p>   stat(apk_path, &amp;apk_stat);</p><p> </p><p>    zip_fd =open(apk_path, O_RDONLY, 0);</p><p>    ......</p><p>   unlink(dex_path);</p><p>    odex_fd= open(dex_path, O_RDWR | O_CREAT | O_EXCL, 0644);</p><p>    ......</p><p>    pid_tpid;</p><p>    pid =fork();</p><p>    if (pid== 0) {</p><p>        ......//uid设置</p><p>        //创建一个新进程，然后对exec dexopt进程进行dex优化</p><p>        run_dexopt(zip_fd,odex_fd, apk_path, dexopt_flags);</p><p>       exit(67);   </p><p>} else {</p><p>        //installd将等待dexopt完成优化工作</p><p>        res= wait_dexopt(pid, apk_path);</p><p>        ......</p><p>    }</p><p>    ......//资源清理</p><p>    return-1;</p><p>}</p></div><p>让人大跌眼镜的是，dex优化工作竟然由installd委派给dexopt进程来实现。dex优化后会生成一个dex文件，一般位于/data/dalvik-cache/目录中。这里给出一个示例，如图4-12所示。</p><p><img src="images/Center.jpg" alt="Center.jpg" /><br /></p><p>图4-12  dex文件示例</p><div><p><strong>提示</strong> dexopt进程由android源码/dalvik/dexopt/OptMain.cpp定义。感兴趣的读者可深入研究dex优化的工作原理。</p></div><h4>3.  movefiles命令分析</h4><p>PKMS扫描完系统Package后，将发送该命令给installd，相应处理函数的代码如下：</p><p>[--&gt;installd.c]</p><div><p>static int do_movefiles(char **arg, charreply[REPLY_MAX])</p><p>{</p><p>    returnmovefiles();</p><p>}</p></div><p>[--&gt;commands.c]</p><div><p>int movefiles()</p><p>{</p><p>    DIR *d;</p><p>    int dfd,subfd;</p><p>    structdirent *de;</p><p>    structstat s;</p><p>    charbuf[PKG_PATH_MAX+1];</p><p>    intbufp, bufe, bufi, readlen;</p><p> </p><p>    charsrcpkg[PKG_NAME_MAX];</p><p>    chardstpkg[PKG_NAME_MAX];</p><p>    charsrcpath[PKG_PATH_MAX];</p><p>    chardstpath[PKG_PATH_MAX];</p><p>    intdstuid=-1, dstgid=-1;</p><p>    inthasspace;</p><p>    //打开/system/etc/updatecmds/目录</p><p>    d =opendir(UPDATE_COMMANDS_DIR_PREFIX);</p><p>    if (d ==NULL) {</p><p>        gotodone;</p><p>    }</p><p>    dfd =dirfd(d);</p><p>       while((de = readdir(d))) {</p><p>        ......//解析该目录下的文件，然后执行对应操作</p><p>   }</p><p>   closedir(d);</p><p>done:</p><p>    return0;</p><p>}</p></div><p>先来看/system/etc/updatecmds/目录下到底是什么文件，这里给出一个示例，如图4-13所示。</p><p><img src="images/Center.jpg" alt="Center.jpg" /><br /></p><p>图4-13  movefiles示例</p><p>以图4-13中最后两行为例，movefiles将把com.google.android.gsf下的databases目录转移到com.andorid.providers.im下。从文件中的注释可知，movefiles的功能和系统升级有关。</p><h4>4.  doFreeCache</h4><p>第3章介绍了DeviceStorageMonitorService，当系统空间不够时，DSMS会调用PKMS的freeStorageAndNotify函数进行空间清理。该工作真正的实施者是installd，相应的处理命令为do_free_cache，其代码如下：</p><p>[--&gt;installd.c]</p><div><p>static int do_free_cache(char **arg, charreply[REPLY_MAX]) </p><p>{</p><p>    returnfree_cache((int64_t)atoll(arg[0]));</p><p>}</p></div><p>[--&gt;commands.c]</p><div><p>int free_cache(int64_t free_size)</p><p>{</p><p>    constchar *name;</p><p>    int dfd,subfd;</p><p>    DIR *d;</p><p>    structdirent *de;</p><p>    int64_tavail;</p><p> </p><p>    avail =disk_free();//获取当前系统的剩余空间大小</p><p>    if(avail &lt; 0) return -1;</p><p>    if(avail &gt;= free_size) return 0;</p><p>    d =opendir(android_data_dir.path);//打开/data/目录</p><p>    dfd =dirfd(d);</p><p>    while((de = readdir(d))) {</p><p>        if (de-&gt;d_type != DT_DIR) continue;</p><p>        name= de-&gt;d_name;</p><p>       ......//略过.和..文件</p><p>       subfd = openat(dfd, name, O_RDONLY | O_DIRECTORY);</p><p>        //删除/data及各级子目录中的cache文件夹</p><p>       delete_dir_contents_fd(subfd, "cache");</p><p>       close(subfd);</p><p>       ......//如果剩余空间恢复正常，则返回</p><p>    }</p><p>   closedir(d);</p><p>    return-1;//清理空间后，仍然不满足要求</p><p>}</p></div><p>installd的介绍就到此为止，这部分内容比较简单，读者完全可自行深入研究。</p><h3>4.6.2  UserManager介绍</h3><p>UserManager是Andorid 4.0新增的一个功能，其作用是管理手机上的不同用户。这一点和PC上的Windows系统比较相似，例如，在Windows上安装程序时，都会提示是安装给本人使用还是安装给系统所有用户使用。非常遗憾的是，在目前的Andorid版本中，该功能尚未完全实现，在SDK中也没有相关说明。不过从现有代码中，也能发现一些蛛丝马迹。</p><div><p><strong>提示</strong> 小米手机的访客模式和UserManager比较相似。</p></div><h4>1.  UserManager构造函数分析</h4><p>在PKMS中，创建UserManager调用的代码如下：</p><div><p>//mUserAppDataDir指向/data/app。该目录中包含的是非系统APK文件</p><p>mUserManager = new UserManager(mInstaller,mUserAppDataDir);</p></div><p>[--&gt;UserManager.java]</p><div><p>public UserManager(Installer installer, FilebaseUserPath) {</p><p>   this(Environment.getDataDirectory(), baseUserPath);</p><p>   mInstaller = installer;</p><p>}</p><p>UserManager(File dataDir, File baseUserPath) {</p><p>   //mUsersDir指向/data/system/users目录</p><p>   mUsersDir = new File(dataDir, USER_INFO_DIR);</p><p>   mUsersDir.mkdirs();//创建该目录</p><p>   mBaseUserPath = baseUserPath;</p><p>   FileUtils.setPermissions(mUsersDir.toString(),</p><p>            FileUtils.S_IRWXU|FileUtils.S_IRWXG</p><p>           |FileUtils.S_IROTH|FileUtils.S_IXOTH,</p><p>               -1, -1);</p><p>   //mUserListFile指向/data/system/user/userlist.xml</p><p>   mUserListFile = new File(mUsersDir, USER_LIST_FILENAME);</p><p>   readUserList();//解析userlist.xml文件</p><p>}</p></div><p>此处不深入readUserList代码了，只介绍其内部工作流程。</p><p>·  userlist.xml保存每个用户的id。</p><p>·  readUserList到/data/system/users下解析id.xml，将最终得到的信息保存在UserInfo对象中。</p><p>原来用户信息由UserInfo表达，下面是UserInfo的定义。</p><p>[--&gt;UserInfo]</p><div><p>public class UserInfo implements Parcelable {</p><p>   //主用户，全系统只能有一个这样的用户</p><p>    publicstatic final int FLAG_PRIMARY = 0x00000001;</p><p> </p><p>    //管理员，可以创建、删除其他用户信息</p><p>    publicstatic final int FLAG_ADMIN   =0x00000002;</p><p>    //访客用户</p><p>    publicstatic final int FLAG_GUEST   =0x00000004;</p><p>    publicint id; //id</p><p>    publicString name;//用户名</p><p>    publicint flags; //属性标志</p><p>    ......//其他函数</p><p>}</p></div><p>UserInfo信息比较简单，笔者觉得UserManager的功能暂时还不能企业用户的需求。感兴趣的读者不妨关注Android未来版本在此方面的变化。</p><h4>2.  installPackageForAllUsers分析</h4><p>PKMS在扫描非系统APK的时候，每扫描完一个APK都会调用installPackageForAllUsers，调用代码如下：</p><div><p>mUserManager.installPackageForAllUsers(pkgName,pkg.applicationInfo.uid);</p></div><p>[--&gt;UserManager.java::installPackageForAllUsers]</p><div><p>public void installPackageForAllUsers(StringpackageName, int uid) {</p><p> for (intuserId : mUserIds) {</p><p>   if(userId == 0)</p><p>      continue;</p><p>  //向installd发送命令，其中getUid将组合userId和uid为一个整型值</p><p>  //installd将在/data/对应user/目录下创建相应的package子目录</p><p>  mInstaller.createUserData(packageName, PackageManager.getUid(userId,uid),</p><p>                                  userId);</p><p>        }</p><p> }</p></div><p> </p><h2>4.7  本章学习指导</h2><p>PKMS是本书分析的第一个重要核心服务，其中的代码量，关联的知识点，涉及的数据结构都比较多。这里提出一些学习建议供读者参考。</p><p>·  从工作流程上看，PKMS包含几条重要的主线。一条是PKMS自身启动时构造函数的工作流程，另外几条和APK安装、卸载相关。每一条主线的难度都比较大，读者可结合日常工作的需求进行单独研究，例如研究如何加快构造函数的执行时间等。</p><p>·  从数据结构上看，PKMS涉及非常多的数据类型。如果对每个数据结构进行孤立分析，很容易陷入不可自拔的状态。笔者建议不妨跳出各种数据结构的具体形态，只从目的及功能角度去考虑。这里需要读者仔细查看前面的重要数据结构及说明示意图。</p><p>另外，由于篇幅所限，本章还有一些内容并没有涉及，需要读者在学习本章内容的基础上自行研究。这些内容包括：</p><p>·  APK安装在SD卡，以及APK从内部存储转移到SD卡的流程。</p><p>·  和Package相关的内容，例如签名管理、dex优化等。</p><h2>4.8  本章小结</h2><p>本章对PackageManagerService进行了较深入的分析。首先分析了PKMS创建时构造函数的工作流程；接着以APK安装为例，较详细地讲解了这个复杂的处理流程；然后又介绍了PKMS另外一项功能，即根据Intent查找匹配的Activities；最后，介绍了与installd和UserManager有关的知识。</p><div><br /><hr /><div><p><a>[①]</a> Signature和Android安全机制有关。本系列书后续拟考虑编写有关Android安全方面的专题卷。</p></div></div> <div> <p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p> </div> </div>